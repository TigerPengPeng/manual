<?xml version="1.0" encoding="utf-8"?>
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US">
<head>
<meta http-equiv="content-type" content="text/html; charset=us-ascii" />

<title>Advanced JGSS Security Programming</title>

<link rel="stylesheet" href="../../../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->


<!-- part II -->
<h1><a name="PART2" id="PART2">Part II : Secure Communications using the Java SE 6 Security API</a></h1>
<p>This part shows you how to build applications that perform secure communications. The Java SE 6 platform provides three standard APIs that allow applications to perform secure communications: The Java Generic Security Service (GSS), the Java SASL API, and the Java Secure Socket Extension (JSSE). When building an application, which of these APIs should you use? The answer depends on many factors, including requirements of the protocol or service, deployment infrastructure, and integration with other security services. For example, if you are building an LDAP client library, you would need to use the Java SASL API because use of SASL is part of LDAP's protocol definition. As an other example, if the service supports SSL, then the client application attempting to access the service would need to use JSSE.</p>
<h2><a name="JGSS" id="JGSS"></a>Exercise 3: Using the Java Generic Security Service (GSS) API</h2>
<br />
<h3>Goal of this exercise:</h3>
<p><br />
The goal of this exercise is to learn how to use the Java GSS API &nbsp;to perform secure authentication and communication.</p>
<a name="JGSSBG" id="JGSSBG"></a>
<h3>Background for this exercise:</h3>
<p>The Generic Security Service API provides a uniform C-language interface to access various security services, such as authentication, message integrity, and message confidentiality. The Java GSS API provides the corresponding interface for Java applications.&nbsp; It allows applications to perform authentication and establish secure communication with the peer. One of the most common security service accessed via the GSS-API and Java GSS-API is Kerberos.</p>
<h3>Resources for this Exercise:</h3>
<ol>
<li><a href="../../../security/jgss/tutorials/index.html">The JAAS and Java GSS-API Tutorials</a></li>
<li><a href="http://www.ietf.org/rfc/rfc2853.txt">Generic Security Service API Version 2: Java Bindings (RFC 2853)</a></li>
<li>Java GSS javadocs: <a href="../../../../../api/org/ietf/jgss/package-summary.html">org.ietf.jgss</a>.</li>
</ol>
<h3>Overview of this Exercise:</h3>
<p>This exercise is a client-server application that demonstrates how to communicate securely using the Java GSS API. The client and server parts first authenticate to Kerberos, as shown in <a href="part1.html#JAAS">Exercise 1</a>. This stores the credentials in the subject. The application then executes an action that performs Java GSS operations (with Kerberos as the underlying GSS mechanism) inside of a <tt>Subject.doAs</tt> using the subject. The Java GSS Kerberos mechanism, because it is executing inside the <tt>doAs</tt>, obtains the Kerberos credentials from the subject, and uses them to authenticate with the peer and to exchange messages securely.</p>
<h3>Steps to follow:</h3>
<ol>
<li>Read the following code. This is located in <a href="./src/GssServer.java"><code>src/GssServer.java.</code></a><br />
<br />
This code fragment defines the action to execute after the service principal has authenticated to the KDC. It replaces the <tt>MyAction</tt> of line 11 of <a href="part1.html#JAAS">Exercise 1</a>. Note the highlighted lines. The code first creates an instance of <b><code>GSSManager</code></b> [line 8], which it uses to obtain its own credentials [line 10-11] and to create an instance of <b><code>GSSContext</code></b> [line 18]. It uses this context to perform authentication [the loop between lines 22-34]. Upon completing authentication, it accepts encrypted input from the client and uses the established security context to decrypt the data [line 45]. It then uses the security context to encrypt a reply containing the original input and the date [line 49], and then sends it back to the client.</li>
</ol>
<p>Code listing for <code>GssServer.java</code>.</p>
<br />
<table summary="" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td><br />
<ol>
<li><code>static class GssServerAction implements PrivilegedExceptionAction {</code></li>
<li><code>...</code></li>
<li><code>&nbsp;&nbsp;public Object run() throws Exception {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Create server socket for accepting connections</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;ServerSocket ss = new ServerSocket(localPort);</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Get own Kerberos credentials for accepting connection</code></li>
<li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;GSSManager manager = GSSManager.getInstance();</code></strong></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;Oid krb5Oid = new Oid("1.2.840.113554.1.2.2");</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;<b>GSSCredential serverCreds = manager.createCredential(null,</b></code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>GSSCredential.DEFAULT_LIFETIME, krb5Oid, GSSCredential.ACCEPT_ONLY);</b></code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;while (true) {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Socket socket = ss.accept();</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream inStream = new DataInputStream(socket.getInputStream());</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataOutputStream outStream = new DataOutputStream(socket.getOutputStream());</code></li>
<li><br /></li>
<li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GSSContext context = manager.createContext((GSSCredential)serverCreds);</code></strong></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Do the context establishment loop</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] token = null;</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (!<strong>context.isEstablished()</strong>) {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Read token</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token = new byte[inStream.readInt()];</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inStream.readFully(token);</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Process token</code></li>
<li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token = context.acceptSecContext(token, 0, token.length);</code></strong></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Send a token to the peer if one was generated by acceptSecContext</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.writeInt(token.length);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.write(token);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.flush();</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Context established!</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create MessageProp for use with unwrap (will be set upon return from unwrap)</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageProp prop = new MessageProp(0, false);</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Read token from client</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token = new byte[inStream.readInt()];</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inStream.readFully(token);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Unwrap (decrypt) token sent by client</code></li>
<li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] input = context.unwrap(token, 0, token.length, prop);</code></strong></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create new token and send to client</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] reply = ...;</code></li>
<li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token = context.wrap(reply, 0, reply.length, prop);</code></strong></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.writeInt(token.length);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.write(token);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.flush();</code></li>
<li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context.dispose();</code></strong></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.close();</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
<li><code>&nbsp;&nbsp;}</code></li>
<li><code>}</code></li>
</ol>
<br /></td>
</tr>
</tbody>
</table>
<br />
<ol start="2">
<li>Compile the sample code.
<b>% javac GssServer.java</b>
<pre>
 
</pre></li>
<li>Read the following code. This is located in <a href="src/GssClient.java"><code>src/GssClient.java.</code></a><br />
<br />
This code fragment defines the action to execute after the client principal has authenticated to the KDC. It replaces the <tt>MyAction</tt> of line 11 of <a href="part1.html#JAAS">Exercise 1</a>. Note the highlighted lines. The code first creates an instance of <b><code>GSSManager</code></b> [line 10], which it uses to obtain a principal name for the service that it is going to communicate with [line 12]. It then creates an instance of <b><code>GSSContext</code></b> [line 15,16] to perform authentication [the loop between lines 22-33] with the service. Upon completing authentication, it uses the established security context to encrypt a message [line 42] and sends it to the server. It then reads an encrypted message from the server and decodes it using the established security context [line 53].</li>
</ol>
Code listing for <code>GssClient.java</code>.<br />
<table summary="" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td><br />
<ol>
<li><code>static class GssClientAction implements PrivilegedExceptionAction {</code></li>
<li><code>...</code></li>
<li><code>&nbsp;&nbsp;public Object run() throws Exception {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Create socket to server</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;Socket socket = new Socket(hostName, port);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream inStream = new DataInputStream(socket.getInputStream());</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;DataOutputStream outStream = new DataOutputStream(socket.getOutputStream());</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Get service's principal name</code></li>
<li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;GSSManager manager = GSSManager.getInstance();</code></strong></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;Oid krb5Oid = new Oid("1.2.840.113554.1.2.2");</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;<b>GSSName serverName = manager.createName(serverPrinc, GSSName.NT_HOSTBASED_SERVICE);</b></code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Get the context for authentication</code></li>
<li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;GSSContext context = manager.createContext(serverName, krb5Oid, null,</code></strong></li>
<li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GSSContext.DEFAULT_LIFETIME);</code></strong></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;context.requestMutualAuth(true); // Request mutual authentication</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;context.requestConf(true); // Request confidentiality</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Do the context establishment loop</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;byte[] token = new byte[0];</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;while (!<strong>context.isEstablished()</strong>) {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>token = context.initSecContext(token, 0, token.length);</b></code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.writeInt(token.length);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.write(token);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.flush();</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Check if we're done</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!<b>context.isEstablished()</b>) {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token = new byte[inStream.readInt()];</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inStream.readFully(token);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Context established!</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Create MessageProp for use with unwrap (true means request confidentiality)</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;MessageProp prop = new MessageProp(0, true);</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Create encrypted message and send to server</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;byte[] reply = ...;</code></li>
<li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;token = context.wrap(reply, 0, reply.length, prop);</code></strong></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;outStream.writeInt(token.length);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;outStream.write(token);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;outStream.flush();</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Read token from server</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;token = new byte[inStream.readInt()];</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;inStream.readFully(token);</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Unwrap (decrypt) token sent by server</code></li>
<li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;byte[] input = context.unwrap(token, 0, token.length, prop);</code></strong></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;...</code></li>
<li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;context.dispose();</code></strong></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;socket.close();</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;return null;</code></li>
<li><code>&nbsp;&nbsp;}</code></li>
<li><code>}</code></li>
</ol>
<br /></td>
</tr>
</tbody>
</table>
<br />
<ol start="4">
<li>Compile the sample code.
<pre>
<b>% javac GssClient.java
</b>
</pre></li>
<li>Launch a new window and start the server.
<pre>
<b>% xterm &amp;
% java -Djava.security.auth.login.config=jaas-krb5.conf \
       GssServer
</b>
</pre></li>
<li>Run the client application. <tt>GssClient</tt> takes two parameters: the service name and the name of the server that the service is running on. For example, if the service is <b><code>host</code></b> running on the machine <b><code>j1hol-001</code></b>, you would enter the following. When prompted for the password, enter <b><tt>changeit</tt></b>.
<pre>
<b>    
% java -Djava.security.auth.login.config=jaas-krb5.conf \
       GssClient host j1hol-001
</b>
</pre></li>
<li>Observe the following output in the client and server applications' windows.</li>
</ol>
<p>Output for running GssServer example.</p>
<table summary="" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td><br />
<ol>
<li><code>Authenticated principal: [host/j1hol-001@J1LABS.EXAMPLE.COM]</code></li>
<li><code>Waiting for incoming connections...</code></li>
<li><code>Got connection from client /192.0.2.102</code></li>
<li><code>Context Established!</code></li>
<li><code>Client principal is test@J1LABS.EXAMPLE.COM</code></li>
<li><code>Server principal is host/j1hol-001@J1LABS.EXAMPLE.COM</code></li>
<li><code>Mutual authentication took place!</code></li>
<li><code>Received data "Hello There!" of length 12</code></li>
<li><code>Confidentiality applied: true</code></li>
<li><code>Sending: Hello There! Thu May 06 12:11:15 PDT 2005</code></li>
</ol>
<br /></td>
</tr>
</tbody>
</table>
<p>Output for running GssClient example.</p>
<table summary="" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td><br />
<ol>
<li><code>Kerberos password for test: changeit</code></li>
<li><code>Authenticated principal: [test@J1LABS.EXAMPLE.COM]</code></li>
<li><code>Connected to address j1hol-001/192.0.2.102</code></li>
<li><code>Context Established!</code></li>
<li><code>Client principal is test@J1LABS.EXAMPLE.COM</code></li>
<li><code>Server principal is host@j1hol-001</code></li>
<li><code>Mutual authentication took place!</code></li>
<li><code>Sending message: Hello There!</code></li>
<li><code>Will read token of size 93</code></li>
<li><code>Received message: Hello There! Thu May 06 12:11:15 PDT 2005</code></li>
</ol>
<br /></td>
</tr>
</tbody>
</table>
<p>Summary:</p>
<p>In this exercise, you learned how to write a client-server application that uses the Java GSS API to authenticate and communicate securely with each other.</p>
<h3>Next Steps</h3>
<ol>
<li>Proceed to <a href="#SASL">Exercise 4</a> to learn how to write a client/server application that uses the Java SASL API to authenticate and communicate securely with each other.</li>
<li>Proceed to <a href="#JSSE">Exercise 5</a> to learn how to write a client/server application that uses the JSSE to authenticate and communicate securely with each other.</li>
<li>Proceed to <a href="part3.html#SSO">Exercise 6</a> to learn how to configure the sample programs that you have just used to achieve single sign-on in a Kerberos environment.</li>
</ol>
<hr />
<h2><a name="SASL" id="SASL"></a>Exercise 4: Using the Java SASL API<br /></h2>
<h3>Goal of this exercise:</h3>
<p>The goal of this exercise is to learn how to use the Java SASL API &nbsp;to perform secure authentication and communication.</p>
<h3>Background for this exercise:</h3>
<p>Simple Authentication and Security Layer (SASL) specifies a challenge-response protocol in which data is exchanged between the client and the server for the purposes of authentication and (optional) establishment of a security layer on which to carry on subsequent communications. SASL allows different <em>mechanisms</em> to be used; each such mechanism is identified by a profile that defines the data to be exchanged and a name. SASL is used with connection-based protocols such as LDAPv3 and IMAPv4. SASL is described in <a href="http://www.ietf.org/rfc/rfc4422.txt">RFC 4422</a>.</p>
<p>The Java SASL API defines an API for applications to use SASL in a mechanism-independent way. For example, if you are writing a library for a networking protocol that uses SASL, you can use the Java SASL API to generate the data to be exchanged with the peer. When the library is deployed, you can dynamically configure the mechanisms to use with the library.</p>
<p>In addition to authentication, you can use SASL to negotiate a security layer to be used after authentication. But unlike the GSS-API, the properties of the security layer (such as whether you want integrity or confidentiality) is decided at negotiation time. (the GSS-API allows confidentiality to be turned on or off per message).</p>
<h3>Resources for this exercise:</h3>
<ol>
<li><a href="../../../security/sasl/sasl-refguide.html">The Java SASL API Programming and Deployment Guide</a></li>
<li><a href="../../../../../api/javax/security/sasl/package-summary.html">The Java SASL API javadocs</a></li>
<li><a href="http://www.ietf.org/rfc/rfc4422.txt">Simple Authentication and Security Layer (SASL) (RFC 4422)</a><br /></li>
</ol>
<h3>Overview of this exercise:</h3>
<p>This exercise is a client-server application that demonstrates how to communicate securely using the Java SASL API. The client and server parts first authenticate to Kerberos using <a href="part1.html#JAAS">Exercise 1</a>. This stores the credentials in the subject. The application then executes an action that performs Java SASL API operations (with Kerberos as the underlying SASL mechanism) inside of a <tt>Subject.doAs</tt> using the subject. The SASL/Kerberos mechanism, because it is executing inside the <tt>doAs</tt>, obtains the Kerberos credentials from the subject, and uses them to authenticate with the peer and to exchange messages securely.</p>
<p>This example uses a simple protocol implemented by the <code><a href="src/AppConnection.java">AppConnection</a></code> class. This protocol exchanges authentication commands and data commands. Each command consists of a type (e.g., <tt>AppConnection.AUTH_CMD</tt>), the length of the data to follow, and the data itself. The data is a SASL buffer if it is for authentication or encrypted/integrity-protected application data; it is plain application data otherwise.</p>
<h3>Steps to follow:</h3>
<ol>
<li>Read the following code. This is located in <a href="src/SaslTestServer.java"><code>src/SaslTestServer.java.</code></a><br />
<br />
This code fragment defines the action to execute after the service principal has authenticated to the KDC. It replaces the <tt>MyAction</tt> of line 11 of <a href="part1.html#JAAS">Exercise 1</a>. Note the highlighted lines. The server specifies the quality-of-protections that it will support [line 9] and then creates an instance of <b><tt>SaslServer</tt></b> to perform the authentication [line 21]. The challenge-response protocol of SASL is performed in the while loop [lines 33-49], with the server sending challenges to the client and processing the responses from the client. After authentication, the identity of the authenticated client can be obtained via a call to <b><tt>getAuthorizedID()</tt></b> [line 61]. If a security layer was negotiated, the server can exchange data securely with the client [lines 66,70].</li>
</ol>
<p>Code listing for <code>SaslTestServer.java</code>.</p>
<table summary="" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td><br />
<ol>
<li><code>static class SaslServerAction implements PrivilegedExceptionAction {</code></li>
<li><code>...</code></li>
<li><code>&nbsp;&nbsp;public Object run() throws Exception {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Create server socket for accepting connections</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;ServerSocket ss = new ServerSocket(localPort);</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Support all quality-of-protection options</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;HashMap&lt;String,Object&gt; props = new HashMap&lt;String,Object&gt;();</code></li>
<li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;props.put(Sasl.QOP, "auth-conf,auth-int,auth");</code></strong></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;while (true) {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create application-level connection to handle request</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Socket socket = ss.accept();</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AppConnection conn = new AppConnection(socket);</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Normally, the application protocol will negotiate which</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// SASL mechanism to use. In this simplified example, we</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// will always use "GSSAPI" (the name of the mechanism that does Kerberos via GSS-API)</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create SaslServer to perform authentication</code></li>
<li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SaslServer srv = Sasl.createSaslServer("GSSAPI", service, serviceName, props, cbh);</code></strong></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (srv == null) {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ... handle error</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Read the initial response from client</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] <strong>response</strong> = conn.receive(AppConnection.AUTH_CMD);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AppConnection.AppReply clientMsg;</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean auth = false;</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Perform authentication</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (!<strong>srv.isComplete()</strong>) {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Generate challenge based on response</code></li>
<li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] challenge = srv.evaluateResponse(response);</code></strong></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (<strong>srv.isComplete()</strong>) {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conn.send(AppConnection.SUCCESS, <strong>challenge</strong>);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auth = true;</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clientMsg = conn.send(AppConnection.AUTH_IN_PROGRESS, <strong>challenge</strong>);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>response</strong> = clientMsg.getBytes();</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (SaslException e) {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Send failure notification to client</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conn.send(AppConnection.FAILURE, null);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Authentication completed!</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Check status of authentication</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (<strong>srv.isCompleted()</strong> &amp;&amp; auth) {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("authorized client is: " + <strong>srv.getAuthorizationID()</strong>);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Report failure ...</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Find out whether security layer was negotiated</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String qop = (String) <strong>srv.getNegotiatedProperty(Sasl.QOP)</strong>;</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean sl = (qop.equals("auth-conf") || qop.equals("auth-int"));</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Read and decrypt message from client</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] msg = conn.receive(AppConnection.DATA_CMD);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] realMsg = (sl ? <strong>srv.unwrap(msg, 0, msg.length)</strong> : msg);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create and encrypt message to send to client</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] reply = ...;</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] realReply = (sl ? <strong>srv.wrap(reply, 0, reply.length)</strong> : reply);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conn.send(AppConnection.SUCCESS, realReply);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
<li><code>&nbsp;&nbsp;}</code></li>
<li><code>}</code></li>
</ol>
<br /></td>
</tr>
</tbody>
</table>
<br />
<ol start="2">
<li>Compile the sample code.
<pre>
<b>% javac SaslTestServer.java<br /></b>
</pre></li>
<li>Read the following code. This is located in <a href="src/SaslTestClient.java"><code>src/SaslTestClient.java.</code></a> This code fragment defines the action to execute after the client principal has authenticated to the KDC. It replaces the <tt>MyAction</tt> of line 11 of <a href="part1.html#JAAS">Exercise 1</a>. Note the highlighted lines. The program first specifies the quality of protection that it wants (in this case, confidentiality) [line 8] and then creates an instance of <b><tt>SaslClient</tt></b> to use for authentication [lines 11-12]. It then checks whether the mechanism has an initial response and if so, gets the response by invoking <b><tt>evaluateChallenge()</tt></b> with an empty byte array [line 20]. It then sends the response to the server to begin the authentication. The challenge-response protocol of SASL is performed in the while loop [lines 24-39], with the client evaluating the challenges that it gets from the server and sending the server the corresponding
responses to the challenges. After authentication, the client can proceed to communicate with the server using the negotiated security layer [lines 48,55].</li>
</ol>
<p>Code listing for <code>SaslTestClient.java</code>.</p>
<table summary="" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td><br />
<ol>
<li><code>static class SaslClientAction implements PrivilegedExceptionAction {</code></li>
<li><code>...</code></li>
<li><code>&nbsp;&nbsp;public Object run() throws Exception {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Create application-level connection</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;AppConnection conn = new AppConnection(serverName, port);</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;HashMap&lt;String,Object&gt; props = new HashMap&lt;String,Object&gt;();</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>props.put(Sasl.QOP, "auth-conf");</strong> // Request confidentiality</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Create SaslClient to perform authentication</code></li>
<li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;SaslClient clnt = Sasl.createSaslClient(</code></strong></li>
<li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new String[]{"GSSAPI"}, null, service, serverName, props, cbh);</code></strong></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;if (clnt == null) {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ... handle error</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;byte[] challenge;</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Get initial response for authentication</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>byte[] response = clnt.hasInitialResponse() ? clnt.evaluateChallenge(EMPTY) : EMPTY;</strong></code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;AppConnection.AppReply reply = conn.send(AppConnection.AUTH_CMD, response);</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Repeat until authentication terminates</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;while (!<strong>clnt.isComplete()</strong> &amp;&amp;</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reply.getStatus() == AppConnection.AUTH_INPROGRESS ||</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reply.getStatus() == AppConnection.SUCCESS))</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Evaluate challenge to generate response</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>challenge</strong> = reply.getBytes()</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>response = clnt.evaluateChallenge(challenge)</strong></code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (reply.getStatus() == AppConnection.SUCCESS) {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (response != null) {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Exception("Protocol error")</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Send response to server and read server's next challenge</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reply = conn.send(AppConnection.AUTH_CMD, <strong>response</strong>);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Authentication completed!</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Find out whether security layer was negotiated</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;String qop = (String) <strong>srv.getNegotiatedProperty(Sasl.QOP)</strong>;</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;boolean sl = (qop.equals("auth-conf") || qop.equals("auth-int"));</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;byte[] msg = ...;</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Create and send encrypted data to server</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;byte[] encrypted = (sl ? <strong>clnt.wrap(msg, 0, msg.length)</strong> : msg);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;reply = conn.send(AppConnection.DATA_CMD, encrypted);) {</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;...</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Read and decrypt data from server</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;byte[] encryptedReply = reply.getBytes();</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;byte[] clearReply = (sl ? <strong>clnt.unwrap(encryptedReply, 0, encryptedReply.length)</strong></code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: encryptedReply);</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;conn.close();</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;return null;</code></li>
<li><code>&nbsp;&nbsp;}</code></li>
<li><code>}</code></li>
</ol>
<br /></td>
</tr>
</tbody>
</table>
<ol start="4">
<li>Compile the sample code.
<pre>
<b>% javac SaslTestClient.java<br /></b>
</pre></li>
<li>Launch a new window and start the server. <tt>SaslTestServer</tt> takes two parameters: the service name and the name of the server that the service is running on. For example, if the service is <b><code>host</code></b> running on the machine <b><code>j1hol-001</code></b>, you would enter the following.
<pre>
<b>% xterm &amp;<br />
% java <br />
 -Djava.security.auth.login.config=jaas-krb5.conf \<br />
       SaslTestServer host j1hol-001<br />
<br />
    </b>
</pre></li>
<li>Run the client application. <tt>SaslTestClient</tt> takes two parameters: the service name and the name of the server that the service is running on. For example, if the service is <b><code>host</code></b> running on the machine <b><code>j1hol-001</code></b>, you would enter the following. When prompted for the password, enter <b><tt>changeit</tt></b>.
<br />
% java -Djava.security.auth.login.config=jaas-krb5.conf \<br />
SaslTestClient host j1hol-001<br />
</li>
<li>Observe the following output in the client and server applications' windows.</li>
</ol>
<p>Output for running the <code>SaslTestServer</code> example.</p>
<table summary="" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td><br />
<ol>
<li><code>Authenticated principal: [host/j1hol-001@J1LABS.EXAMPLE.COM]</code></li>
<li><code>Waiting for incoming connections...</code></li>
<li><code>Got connection from client /192.0.2.102</code></li>
<li><code>Client authenticated; authorized client is: test@J1LABS.EXAMPLE.COM</code></li>
<li><code>Negotiated QOP: auth-conf</code></li>
<li><code>Received: Hello There!</code></li>
<li><code>Sending: Hello There! Fri May 07 15:32:37 PDT 2005</code></li>
<li><code>Received data "Hello There!" of length 12</code></li>
</ol>
<br /></td>
</tr>
</tbody>
</table>
<p>Output for running the <code>SaslTestClient</code> example.</p>
<table summary="" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td><br />
<ol>
<li><code>Kerberos password for test: changeit</code></li>
<li><code>Authenticated principal: [test@J1LABS.EXAMPLE.COM]</code></li>
<li><code>Connected to address j1hol-001/192.0.2.102</code></li>
<li><code>Client authenticated.</code></li>
<li><code>Negotiated QOP: auth-conf</code></li>
<li><code>Sending: Hello There!</code></li>
<li><code>Received: Hello There! Fri May 07 15:32:37 PDT 2005</code></li>
</ol>
<br /></td>
</tr>
</tbody>
</table>
<ol start="8">
<li>To try the program using different quality-of-protection, change line 8 in <code>SaslTestClient</code>. For example, replace line 8 with the following line to use integrity protection on (no confidentiality).
<pre>
<b>props.put(Sasl.QOP, "auth-int");</b>
</pre></li>
</ol>
<h3>Summary:</h3>
<p>In this exercise, you learned how to write a client-server application that uses the Java SASL API to authenticate and communicate securely with each other.</p>
<h3>Next Steps</h3>
<ol>
<li>Proceed to <a href="#JSSE">Exercise 5</a> to learn how to write a client/server application that uses the JSSE to authenticate and communicate securely with each other.</li>
<li>Proceed to <a href="part3.html#SSO">Exercise 6</a> to learn how to configure the sample programs that you have just used to achieve single sign-on in a Kerberos environment.</li>
</ol>
<hr />
<h2><a name="JSSE" id="JSSE"></a>Exercise 5: Using the Java Secure Socket Extension with Kerberos</h2>
<h3>Goal of this exercise:</h3>
<p>The goal of this exercise is to learn how to use the JSSE API &nbsp;to perform secure authentication and communication using Kerberos cipher suites.</p>
<h3>Background for this exercise:</h3>
<p>Secure Socket Layer (SSL) and Transport Layer Security (TLS) are the most widely used protocols for implementing cryptography on the Internet. TLS is the Internet standard evolved from SSL. SSL/TLS provides application-level protocols (such as HTTP and LDAP) with secure authentication and communication. For example, HTTPS is the resulting protocol of using HTTP over SSL/TLS. SSL/TLS is used not only for standard protocols such as HTTP, it is also widely used when building custom applications using custom protocols that need to communicate securely.</p>
<p>SSL/TLS traditionally used certificate-based authentication and is commonly used for server-authentication. For example, when a Web client such as a browser accesses a secure Web site (server) on behalf of a user, the server sends its certificate to the browser so that the browser can verify the identity of the server. This ensures that the user does not divulge confidential information (such as credit card information) to a bogus server. Recently, a new standard allows the use of Kerberos with TLS. This means instead of using certificate-based authentication, an application can use Kerberos credentials and take advantage of the Kerberos infrastructure in the deployment environment. Using Kerberos cipher suites also provides automatic support for mutual authentication in which the client is also authenticated in addition to the server.</p>
<p>The decision of whether to use Java GSS, Java SASL, or JSSE for a particular application often depends upon several factors, including (the protocols being used by) the services with which the application interacts, the deployment environment (PKI or Kerberos-based), and the application's security requirements. JSSE provides a secure end-to-end channel that takes care of the I/O and transport, while Java GSS and Java SASL provide encryption and integrity-protection on the data, but the application is responsible for transporting the secured data to its peer. Some details about factors for deciding when to use JSSE versus Java GSS are presented in the document, <a href="../../../security/jgss/tutorials/JGSSvsJSSE.html">When to use Java GSS vs. JSSE</a>.</p>
<h3>Resources for this exercise:</h3>
<ol>
<li><a href="../../../security/jsse/JSSERefGuide.html">Java Secure Socket Extension (JSSE) Reference Guide</a></li>
<li>The JSSE javadocs: <tt><a href="../../../../../api/javax/net/package-summary.html">javax.net</a></tt> and <a href="../../../../../api/javax/net/ssl/package-summary.html">javax.net.ssl</a></li>
<li><a href="http://netscape.aol.com">The SSL Protocol version 3.0</a></li>
<li><a href="http://www.ietf.org/rfc/rfc2246.txt">The TLS Protocol Version 1.0 (RFC 2246)</a></li>
<li><a href="http://www.ietf.org/rfc/rfc2712.txt">Addition of Kerberos Cipher Suites to Transport Layer Security TLS (RFC 2712)</a></li>
<li><a href="../../../security/jgss/tutorials/JGSSvsJSSE.html">When to use Java GSS vs. JSSE</a></li>
</ol>
<h3>Overview of this exercise:</h3>
<p>This exercise is a client-server application that demonstrates how to communicate securely using the JSSE and Kerberos cipher suites. The client and server parts first authenticate to Kerberos using <a href="part1.html#JAAS">Exercise 1</a>. This stores the credentials in the subject. The application then executes an action that performs JSSE operations (using a Kerberos cipher suite) inside of a <tt>Subject.doAs</tt> using the subject. The Kerberos cipher suite implementation, because it is executing inside the <tt>doAs</tt>, obtains the Kerberos credentials from the subject, and uses them to authenticate with the peer and to exchange messages securely. This example sends newline-terminated messages, encrypted using the negotiated cipher suite and integrity-protected, back and forth between client and server.</p>
<p>According to the standard (RFC 2712) all Kerberos-enabled TLS applications use the same service name, namely, <b>"host"</b>. That is why in this exercise, you do not need to explicitly supply the Kerberos service name.</p>
<h3>Steps to follow:</h3>
<ol>
<li>Read the following code. This is located in <a href="src/JsseServer.java"><code>src/JsseServer.java</code></a><br />
<br />
This code fragment defines the action to execute after the service principal has authenticated to the KDC. It replaces the <tt>MyAction</tt> of line 11 of <a href="part1.html#JAAS">Exercise 1</a>. Note the highlighted lines. The server first creates an <strong><tt>SSLServerSocket</tt></strong> [lines 5-8]. This is analogous to an application creating a plain <tt>ServerSocket</tt> except an <tt>SSLServerSocket</tt> will provide automatic authentication, encryption and decryption, as needed. The server then sets the cipher suites that it wants to use [lines 11-12]. The server then runs in a loop, accepting connections from SSL clients [line 17], and reads and writes from the SSL socket [lines 23, 28]. The server can find out the identities of the owners of socket by invoking the <strong><tt>getLocalPrincipal()</tt></strong> and <strong><tt>getPeerPrincipal()</tt></strong> methods [lines 32-33].</li>
</ol>
<p>Code listing for <code>JsseServer.java</code>.</p>
<table summary="" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td><br />
<ol>
<li><code>static class JsseServerAction implements PrivilegedExceptionAction {</code></li>
<li><code>...</code></li>
<li><code>&nbsp;&nbsp;public Object run() throws Exception {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Create TLS socket for accepting connections</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>SSLServerSocketFactory sslssf =</strong></code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>(SSLServerSocketFactory) SSLServerSocketFactory.getDefault();</strong></code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>SSLServerSocket sslServerSocket =</strong></code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>(SSLServerSocket) sslssf.createServerSocket(localPort);</strong></code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Enable only a Kerberos cipher suite</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;String enabledSuites[] = { "TLS_KRB5_WITH_3DES_EDE_CBC_SHA" };</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>sslServerSocket.setEnabledCipherSuites(enabledSuites);</strong></code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Should handle exception if enabledSuites is not supported</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;while (true) {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create socket to handle request</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();</strong></code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedReader in = new BufferedReader(new InputStreamReader(</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>sslSocket.getInputStream()</strong>));</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedWriter out = new BufferedWriter(new OutputStreamWriter(</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>sslSocket.getOutputStream()</strong>));</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String inStr = <strong>in.readLine()</strong>;</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ... use inStr</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Compose and send reply</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String outStr = inStr + " " + new Date().toString() + "\n";</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>out.write(outStr);</strong></code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.flush();</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get names of principal at both ends of secure connection</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Principal self = sslSocket.getSession().getLocalPrincipal();</strong></code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Principal peer = sslSocket.getSession().getPeerPrincipal();</strong></code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>sslSocket.close();</strong></code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
<li><code>&nbsp;&nbsp;}</code></li>
<li><code>}</code></li>
</ol>
<br /></td>
</tr>
</tbody>
</table>
<br />
<ol start="2">
<li>Compile the sample code.
<br />
% javac JsseServer.java<br />
</li>
<li>Read the following code. This is located in <a href="src/JsseClient.java"><code>src/JsseClient.java</code></a>. This code fragment defines the action to execute after the client principal has authenticated to the KDC. It replaces the <tt>MyAction</tt> of line 11 of <a href="#JAAScode">Exercise 1</a>. Note the highlighted lines. The client first creates an <tt><strong>SSLSocket</strong></tt>. The client then sets the cipher suites that it wants to use [lines 11-12]. The client then exchanges messages with the server using the <tt>SSLSocket</tt> by reading and writing to the socket's input/output streams. The client can find out the identities of the owners of socket by invoking the <strong><tt>getLocalPrincipal()</tt></strong> and <strong><tt>getPeerPrincipal()</tt></strong> methods [lines 26-27].</li>
</ol>
<p>Code listing for <code>JsseClient.java</code></p>
<table summary="" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td><br />
<ol>
<li><code>static class JsseClientAction implements PrivilegedExceptionAction {</code></li>
<li><code>...</code></li>
<li><code>&nbsp;&nbsp;public Object run() throws Exception {</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Create SSL connection</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>SSLSocketFactory sslsf = (SSLSocketFactory) SSLSocketFactory.getDefault();</strong></code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>SSLSocket sslSocket = (SSLSocket) sslsf.createSocket(server, port);</strong></code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Enable only a Kerberos cipher suite</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;String enabledSuites[] = { "TLS_KRB5_WITH_3DES_EDE_CBC_SHA" };</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>sslSocket.setEnabledCipherSuites(enabledSuites);</strong></code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Should handle exception if enabledSuites is not supported</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;BufferedReader in = new BufferedReader(new InputStreamReader(</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>sslSocket.getInputStream()</strong>));</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;BufferedWriter out = new BufferedWriter(new OutputStreamWriter(</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>sslSocket.getOutputStream()</strong>));</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;String outStr = ...;</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>out.write(outStr);</strong></code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;out.flush();</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;String inStr = <strong>in.readLine()</strong>;</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// ... use inStr</code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Get names of principal at both ends of secure connection</code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Principal self = sslSocket.getSession().getLocalPrincipal();</strong></code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Principal peer = sslSocket.getSession().getPeerPrincipal();</strong></code></li>
<li><br /></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>sslSocket.close();</strong></code></li>
<li><code>&nbsp;&nbsp;&nbsp;&nbsp;return null;</code></li>
<li><code>&nbsp;&nbsp;}</code></li>
<li><code>}</code></li>
</ol>
<br /></td>
</tr>
</tbody>
</table>
<br />
<ol start="4">
<li>Compile the sample code.
<pre>
<b>% javac JsseClient.java<br /></b>
</pre></li>
<li>Launch a new window and start the server. <tt>JsseServer</tt> takes one parameter: the name of the server that the JSSE service is running on. For example, if it is running on the machine <b><code>j1hol-001</code></b>, you would enter the following.
<pre>
<b>% xterm &amp;<br />
% java <br />
 -Djava.security.auth.login.config=jaas-krb5.conf \<br />
       JsseServer j1hol-001<br />
<br />
    </b>
</pre></li>
<li>Run the client application. <tt>JsseClient</tt> takes one parameter: the name of the server that the JSSE service is running on. For example, if the service is running on the machine <b><code>j1hol-001</code></b>, you would enter the following. When prompted for a password, enter <b><tt>changeit</tt></b>.
<br />
% java -Djava.security.auth.login.config=jaas-krb5.conf \<br />
JsseClient j1hol-001<br />
</li>
<li>Observe the following output in the client and server applications' windows.</li>
</ol>
<p>Output for running the <code>JsseServer</code> example.</p>
<table summary="" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td><br />
<ol>
<li><code>Authenticated principal: [host/j1hol-001@J1LABS.EXAMPLE.COM]</code></li>
<li><code>Waiting for incoming connections...</code></li>
<li><code>Got connection from client /192.0.2.102</code></li>
<li><code>Received: Hello There!</code></li>
<li><code>Sending: Hello There! Fri May 07 15:32:37 PDT 2005</code></li>
<li><code>Cipher suite in use: TLS_KRB5_WITH_3DES_EDE_CBC_SHA</code></li>
<li><code>I am: host/j1hol-001@J1LABS.EXAMPLE.COM</code></li>
<li><code>Client is: test@J1LABS.EXAMPLE.COM</code></li>
</ol>
<br /></td>
</tr>
</tbody>
</table>
<p>Output for running the <code>JsseClient</code> example.</p>
<table summary="" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td><br />
<ol>
<li><code>Kerberos password for test: changeit</code></li>
<li><code>Authenticated principal: [test@J1LABS.EXAMPLE.COM]</code></li>
<li><code>Sending: Hello There!</code></li>
<li><code>Received: Hello There! Fri May 07 15:32:37 PDT 2005</code></li>
<li><code>Cipher suite in use: TLS_KRB5_WITH_3DES_EDE_CBC_SHA</code></li>
<li><code>I am: test@J1LABS.EXAMPLE.COM</code></li>
<li><code>Server is: host/j1hol-001@J1LABS.EXAMPLE.COM</code></li>
</ol>
<br /></td>
</tr>
</tbody>
</table>
<h3>Summary:</h3>
<p>In this exercise, you learned how to write a client-server application that uses JSSE to authenticate and communicate securely with each other, using Kerberos as the underlying authentication system.</p>
<h3>Next Steps</h3>
<ol>
<li>Proceed to <a href="part3.html#SSO">Exercise 6</a> to learn how to configure the sample programs in Exercises 3, 4, and 5 to achieve single sign-on in a Kerberos environment.</li>
</ol>
<hr />

<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2014, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
