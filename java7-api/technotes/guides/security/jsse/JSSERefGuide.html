<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<!-- *********************************** -->
<head>
<title>JSSE Reference Guide for Java SE</title><link rel="stylesheet" href="../../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->


<h1>Java&trade; Secure Socket Extension (JSSE)<br />
Reference Guide</h1>
<h2>for Java Platform Standard Edition 7</h2>
<br />
<dl>
<dt><a href="#Introduction"><b>Introduction</b></a></dt>
<dd><a href="#Features">Features and Benefits</a></dd>
<dd><a href="#StandardAPI">JSSE Standard API</a></dd>
<dd><a href="#SunJSSE">SunJSSE Provider</a></dd>
<dd><a href="#RelatedDocs">Related Documentation</a></dd>
</dl>
<a href="#Terms"><b>Terms and Definitions</b></a>
<dl>
<dt><a href="#SSLOverview"><b>Secure Sockets Layer (SSL) Protocol
Overview</b></a></dt>
<dd><a href="#WhySSL">Why Use SSL?</a></dd>
<dd><a href="#HowSSLWorks">How SSL Works</a></dd>
</dl>
<dl>
<dt><a href="#KeyClasses"><b>Key Classes</b></a></dt>
<dd><a href="#ClassRelationship"><b>Relationship Between
Classes</b></a></dd>
<dd><a href="#CoreClasses"><b>Core Classes and Interfaces</b></a>
<dl>
<dd><a href="#SocketFactory">SocketFactory and ServerSocketFactory
Classes</a></dd>
<dd><a href="#SSLSocketFactory">SSLSocketFactory and
SSLServerSocketFactory Classes</a></dd>
<dd><a href="#SSLSocket">SSLSocket and SSLServerSocket
Classes</a></dd>
<dd><a href="#SSLENG">Nonblocking I/O with
<code>SSLEngine</code></a></dd>
<dd><a href="#SSLSession">SSLSession and ExtendedSSLSession
Interfaces</a></dd>
<dd><a href="#HttpsURLConnection">HttpsURLConnection Class</a></dd>
</dl>
</dd>
<dd><a href="#SupportClasses"><b>Support Classes and
Interfaces</b></a>
<dl>
<dd><a href="#SSLContext">SSLContext Class</a></dd>
<dd><a href="#TrustManager">TrustManager Interface</a></dd>
<dd><a href="#TrustManagerFactory">TrustManagerFactory
Class</a></dd>
<dd><a href="#X509TrustManager">X509TrustManager Interface</a></dd>
<dd><a href="#X509ExtendedTrustManager">X509ExtendedTrustManager
Class</a></dd>
<dd><a href="#KeyManager">KeyManager Interface</a></dd>
<dd><a href="#KeyManagerFactory">KeyManagerFactory Class</a></dd>
<dd><a href="#X509KeyManager">X509KeyManager Interface</a></dd>
<dd><a href="#X509ExtendedKeyManager">X509ExtendedKeyManager
Class</a></dd>
<dd><a href="#RelsTM_KM">Relationships between TrustManagers and
KeyManagers</a></dd>
</dl>
</dd>
<dd><a href="#SecondarySupportClasses"><b>Secondary Support Classes
and Interfaces</b></a>
<dl>
<dd><a href="#SSLParameters">SSLParameters Class</a></dd>
<dd><a href="#SSLSessionContext">SSLSessionContext
Interface</a></dd>
<dd><a href="#SSLSessionBindingListener">SSLSessionBindingListener
Interface</a></dd>
<dd><a href="#SSLSessionBindingEvent">SSLSessionBindingEvent
Class</a></dd>
<dd><a href=
"#HandShakeCompletedListener">HandShakeCompletedListener
Interface</a></dd>
<dd><a href="#HandShakeCompletedEvent">HandShakeCompletedEvent
Class</a></dd>
<dd><a href="#HostnameVerifier">HostnameVerifier Interface</a></dd>
<dd><a href="#X509Certificate">X509Certificate Class</a></dd>
<dd><a href="#AlgorithmConstraints">AlgorithmConstraints
Interface</a></dd>
</dl>
</dd>
<dd><a href="#ConfigurationClasses"><b>Previous (JSSE 1.0.x)
Implementation Classes and Interfaces</b></a></dd>
</dl>
<dl>
<dt><a href="#InstallationAndCustomization"><b>Customizing
JSSE</b></a></dt>
<dd><a href="#javaHome">The Installation Directory
&lt;java-home&gt;</a></dd>
<dd><a href="#Customization">Customization</a></dd>
</dl>
<dl>
<dt><a href="#tlsRenegotiation"><b>Transport Layer Security (TLS)
Renegotiation Issue</b></a></dt>
<dd><a href="#intro">Introduction</a></dd>
<dd><a href="#phased">Phased Approach to Fixing This Issue</a></dd>
<dd><a href="#descPhase2">Description of Phase 2 Fix</a></dd>
<dd><a href="#workarounds">Workarounds/Alternatives to SSL/TLS
Renegotiation</a></dd>
<dd><a href="#implDetails">Implementation Details</a></dd>
<dd><a href="#descPhase1">Description of the Phase 1 Fix</a></dd>
</dl>
<dl>
<dt><a href="#PKCS11"><b>JCE and Hardware Acceleration/Smartcard
Support</b></a></dt>
<dd><a href="#UseOfJCE">Use of JCE</a></dd>
<dd><a href="#HardwareAccelerators">Hardware Accelerators</a></dd>
<dd><a href="#ConfigSmartcard">Configure JSSE to use Smartcards as
Keystore and Trust Stores</a></dd>
<dd><a href="#MultiDynamicKeystores">Multiple and Dynamic
Keystores</a></dd>
</dl>
<dl>
<dt><a href="#KRB"><b>Kerberos Cipher Suites</b></a></dt>
<dd><a href="#KRBRequire">Kerberos Requirements</a></dd>
<dd><a href="#KRBPeerID">Peer Identity Information</a></dd>
<dd><a href="#KRBSM">Security Manager</a></dd>
</dl>
<p><a href="#KeystoreFormats"><b>Additional Keystore Formats
(PKCS12)</b></a></p>
<dl>
<dt><a href="#Troubleshooting"><b>Troubleshooting</b></a></dt>
<dd><a href="#InstallProbs">Configuration Problems</a></dd>
<dd><a href="#Debug">Debugging Utilities</a></dd>
</dl>
<dl>
<dt><a href="#CodeExamples"><b>Code Examples</b></a></dt>
<dd><a href="#UnsecureSecure">Converting an Unsecure Socket to a
Secure Socket</a></dd>
<dd><a href="#SampleCode">Running the JSSE Sample Code</a></dd>
<dd><a href="#CreateKeystore">Creating a Keystore to Use with
JSSE</a></dd>
</dl>
<a href="#AppA"><b>Appendix A: Standard Names</b></a>
<p><a href="#PLUG"><b>Appendix B: Provider Pluggability</b></a></p>
<hr width="100%" />
<a name="Introduction" id="Introduction"></a> 
<!-- *********************************************** -->
<h1>Introduction</h1>
<p>Data that travels across a network can easily be accessed by
someone who is not the intended recipient. When the data includes
private information, such as passwords and credit card numbers,
steps must be taken to make the data unintelligible to unauthorized
parties. It is also important to ensure the data has not been
modified, either intentionally or unintentionally, during
transport. The Secure Sockets Layer (SSL) and Transport Layer
Security (TLS) protocols were designed to help protect the privacy
and integrity of data while it is transferred across a network.</p>
<p>The Java Secure Socket Extension (JSSE) enables secure Internet
communications. It provides a framework and an implementation for a
Java version of the SSL and TLS protocols and includes
functionality for data encryption, server authentication, message
integrity, and optional client authentication. Using JSSE,
developers can provide for the secure passage of data between a
client and a server running any application protocol, such as
Hypertext Transfer Protocol (HTTP), Telnet, or FTP, over TCP/IP.
(For an introduction to SSL, see <a href="#SSLOverview">Secure
Sockets Layer (SSL) Protocol Overview</a>.)</p>
<p>By abstracting the complex underlying security algorithms and
"handshaking" mechanisms, JSSE minimizes the risk of creating
subtle, but dangerous security vulnerabilities. Furthermore, it
simplifies application development by serving as a building block
which developers can integrate directly into their
applications.</p>
<p>JSSE was previously an optional package to the Java 2 SDK,
Standard Edition (J2SDK), v 1.3. JSSE was integrated into the Java
Standard Edition Development Kit starting with J2SDK 1.4.</p>
<p>JSSE provides both an application programming interface (API)
framework and an implementation of that API. The JSSE API
supplements the "core" network and cryptographic services defined
by the <code>java.security</code> and <code>java.net</code>
packages by providing extended networking socket classes, trust
managers, key managers, SSLContexts, and a socket factory framework
for encapsulating socket creation behavior. Because the socket APIs
were based on a blocking I/O model, in JDK 5.0, a nonblocking
<code>SSLEngine</code>API was introduced to allow implementations
to choose their own I/O methods.</p>
<p>The JSSE API is capable of supporting SSL versions 2.0 and 3.0
and Transport Layer Security (TLS) 1.0. These security protocols
encapsulate a normal bidirectional stream socket and the JSSE API
adds transparent support for authentication, encryption, and
integrity protection. The JSSE implementation shipped with Oracle's
JRE supports SSL 3.0 and TLS 1.0. It does not implement SSL
2.0.</p>
<p>As mentioned above, JSSE is a security component of the Java SE
6 platform, and is based on the same <a href=
"../crypto/CryptoSpec.html#Design">design principles</a> found
elsewhere in the Java Cryptography Architecture (JCA) framework.
This framework for cryptography-related security components allows
them to have implementation independence and, whenever possible,
algorithm independence. JSSE uses the same "<a href=
"../crypto/CryptoSpec.html#ProviderArch">provider</a>" architecture
defined in the JCA.</p>
<p>Other security components in the Java SE 6 platform include the
Java Authentication and Authorization Service (<a href=
"../jaas/JAASRefGuide.html">JAAS</a>), and the <a href=
"../../../tools/index.html#security">Java Security Tools</a>. JSSE
encompasses many of the same concepts and algorithms as those in
JCE but automatically applies them underneath a simple stream
socket API.</p>
<p>The JSSE APIs were designed to allow other SSL/TLS protocol and
Public Key Infrastructure (PKI) implementations to be plugged in
seamlessly. Developers can also provide alternate logic for
determining if remote hosts should be trusted or what
authentication key material should be sent to a remote host.</p>
<!-- *********************************************** -->
<a name="Features" id="Features"></a>
<h2>Features and Benefits</h2>
<p>JSSE includes the following important features:</p>
<ul>
<li>Included as a standard component of JRE 1.4 and later</li>
<li>Extensible, provider based architecture</li>
<li>Implemented in 100% Pure Java</li>
<li>Provides API support for SSL versions 2.0 and 3.0, TLS 1.0 and
later; and an implementation of SSL 3.0 and TLS 1.0</li>
<li>Includes classes that can be instantiated to create secure
channels (<code>SSLSocket</code>, <code>SSLServerSocket</code>, and
<code>SSLEngine</code>)</li>
<li>Provides support for <a href="#CipherSuite">cipher suite</a>
negotiation, which is part of the SSL handshaking used to initiate
or verify secure communications</li>
<li>Provides support for client and server authentication, which is
part of the normal SSL handshaking</li>
<li>Provides support for Hypertext Transfer Protocol (HTTP)
encapsulated in the SSL protocol (HTTPS), which allows access to
data such as web pages using HTTPS</li>
<li>Provides server session management APIs to manage
memory-resident SSL sessions</li>
<li>Provides support for several cryptographic algorithms commonly
used in cipher suites, including those listed in the following
table:</li>
</ul>
<table border="1" summary=
"Cryptographic Functionality Available With JSSE">
<caption>Cryptographic Functionality Available With JSSE</caption>
<tbody>
<tr>
<th>Cryptographic Algorithm<a class="footnote" href="#footnote-one">Footnote 1</a></th>
<th>Cryptographic Process</th>
<th>Key Lengths (Bits)</th>
</tr>
<tr>
<td>RSA</td>
<td>Authentication and key exchange</td>
<td>512 and larger</td>
</tr>
<tr>
<td>RC4</td>
<td>Bulk encryption</td>
<td>128<br />
128 (40 effective)</td>
</tr>
<tr>
<td>DES</td>
<td>Bulk encryption</td>
<td>64 (56 effective)<br />
64 (40 effective)</td>
</tr>
<tr>
<td>Triple DES</td>
<td>Bulk encryption</td>
<td>192 (112 effective)</td>
</tr>
<tr>
<td>AES</td>
<td>Bulk encryption</td>
<td>256<a class="footnote" href="#footnote-two">Footnote 2</a><br />
128</td>
</tr>
<tr>
<td>Diffie-Hellman</td>
<td>Key agreement</td>
<td>1024<br />
512</td>
</tr>
<tr>
<td>DSA</td>
<td>Authentication</td>
<td>1024</td>
</tr>
</tbody>
</table>
<p><a class="footnote" name="footnote-one" id=
"footnote-one">Footnote 1</a> <small>Note: The
SunJSSE implementation uses the <a href=
"../crypto/CryptoSpec.html">Java Cryptography Extension (JCE)</a>
for all its cryptographic algorithms.</small></p>
<p><a class="footnote" name="footnote-two" id=
"footnote-two">Footnote 2</a> <small>Cipher suites
that use AES_256 require installation of the JCE Unlimited Strength
Jurisdiction Policy Files. See <a href=
"http://www.oracle.com/technetwork/java/javase/downloads/index.html">
Java SE Download Page</a>.</small></p>
<!-- *********************************************** -->
<a name="StandardAPI" id="StandardAPI"></a>
<h2>JSSE Standard API</h2>
<p>The JSSE standard API, available in the <code>javax.net</code>
and <code>javax.net.ssl</code> packages, covers:</p>
<ul>
<li>Secure (SSL) sockets and server sockets.</li>
<li>A nonblocking engine for producing and consuming streams of
SSL/TLS data (SSLEngine).</li>
<li>Factories for creating sockets, server sockets, SSL sockets,
and SSL server sockets. Using socket factories you can encapsulate
socket creation and configuration behavior.</li>
<li>A class representing a secure socket context that acts as a
factory for secure socket factories and engines.</li>
<li>Key and trust manager interfaces (including X.509-specific key
and trust managers), and factories that can be used for creating
them.</li>
<li>A class for secure HTTP URL connections (HTTPS).</li>
</ul>
<!-- *********************************************** -->
<a name="SunJSSE" id="SunJSSE"></a>
<h2><code>SunJSSE</code> Provider</h2>
<p>Oracle's implementation of Java SE includes a JSSE provider
named "<code>SunJSSE</code>", which comes pre-installed and
pre-registered with the JCA. This provider supplies the following
cryptographic services:</p>
<ul>
<li>
<p>An implementation of the SSL 3.0 and TLS 1.0 security
protocols.</p>
</li>
<li>
<p>An implementation of the most common SSL and TLS cipher suites
which encompass a combination of authentication, key agreement,
encryption and integrity protection.</p>
</li>
<li>
<p>An implementation of an X.509-based key manager which chooses
appropriate authentication keys from a standard JCA keystore.</p>
</li>
<li>
<p>An implementation of an X.509-based trust manager which
implements rules for certificate chain path validation.</p>
</li>
<li>
<p>An implementation of PKCS12 as JCA keystore type "pkcs12".
Storing trusted anchors in PKCS12 is not supported. Users should
store trust anchors in JKS format and save private keys in PKCS12
format.</p>
</li>
</ul>
More information about this provider is available in the <a href=
"../SunProviders.html#SunJSSEProvider">SunJSSE</a> section. 
<!-- *********************************************** -->
 <a name="RelatedDocs" id="RelatedDocs"></a>
<h2>Related Documentation</h2>
<h3>Java Secure Socket Extension Documentation</h3>

<ul>
<li>JSSE API documentation:<br />
<ul>
<li><em><a href=
"../../../../api/javax/net/package-summary.html">javax.net
package</a></em></li>
<li><em><a href=
"../../../../api/javax/net/ssl/package-summary.html">javax.net.ssl
package</a></em></li>
<li><em><a href=
"../../../../api/javax/security/cert/package-summary.html">javax.security.cert
package</a></em></li>
</ul>
</li>
</ul>
<h3>Java Platform Security Documentation</h3>
<ul>
<li>
<p>The Java Security home page has links to White Papers, Books,
Secure Coding guidelines, etc:<br />
<em><a href=
"http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136007.html">
Java SE Security</a></em></p>
</li>
<li>
<p>The Java Certification Path API Programmer's Guide:<br />
<em><a href=
"../certpath/CertPathProgGuide.html"><code>CertPath</code>
Programmer's Guide</a></em></p>
</li>
<li>
<p>Links to more Java SE 6 platform security documents:<br />
<em><a href="../index.html">Security Guides page</a></em></p>
</li>
<li>
<p>Tutorial for Java platform security:<br />
<em><a href=
"http://docs.oracle.com/javase/tutorial/security/">Security
Features in Java SE</a></em></p>
</li>
<li>Book on Java SE platform security:<br />
<em><a href=
"http://www.oracle.com/technetwork/java/javaee/gong-135902.html">Inside Java 2
Platform Security: Architecture, API Design, and Implementation</a>
by Li Gong. Addison Wesley Longman, Inc., 1999. ISBN:
0201310007.</em></li>
</ul>
<h3>Export Issues Related to Cryptography</h3>
<p>For information on U.S. encryption policies, refer to these Web
sites:</p>
<ul>
<li>
<p>U.S. Department of Commerce:<br />
<em><a href=
"http://www.commerce.gov/">http://www.commerce.gov</a></em></p>
</li>
<li>
<p>Export Policy Resource Page:<br />
<em><a href=
"http://www.crypto.com/">http://www.crypto.com/</a></em></p>
</li>
<li>
<p>Computer Systems Public Policy:<br />
<em><a href="http://www.techceocouncil.org">http://www.cspp.org/</a></em></p>
</li>
<li>
<p>Federal Information Processing Standards Publications (FIPS
PUBS) homepage, which has links to the Data Encryption Standard
(DES):<br />
<em><a href=
"http://www.itl.nist.gov/fipspubs/">http://www.itl.nist.gov/fipspubs/</a></em></p>
</li>
<li>
<p>Revised U.S. Encryption Export Control Regulations:<br />
<em><a href="http://epic.org/crypto/export_controls/regs_1_00.html">http://www.epic.org/crypto/export_controls/regs_1_00.html</a></em></p>
</li>
</ul>
<a name="CryptDocs" id="CryptDocs"></a>
<h3>Cryptography Documentation</h3>
<p>Online resources:</p>
<ul>
<li>Dr. Rivest's Cryptography and Security page:<br />
<em><a href="http://people.csail.mit.edu/rivest/crypto-security.html">http://theory.lcs.mit.edu/~rivest/crypto-security.html</a></em></li>
</ul>
<p>Books:</p>
<ul>
<li>
<p><em>Applied Cryptography, Second Edition</em> by Bruce Schneier.
John Wiley and Sons, Inc., 1996.</p>
</li>
<li>
<p><em>Cryptography Theory and Practice</em> by Doug Stinson. CRC
Press, Inc., 1995.</p>
</li>
<li>
<p><em>Cryptography &amp; Network Security: Principles &amp;
Practice</em> by William Stallings. Prentice Hall, 1998.</p>
</li>
</ul>
<a name="SSLDocs" id="SSLDocs"></a>
<h3>Secure Sockets Layer Documentation</h3>
<p>Online resources:</p>
<ul><!-- <li><p>Documentation from Netscape about SSL: <br>
          <em> <a
 href="http://developer.netscape.com/docs/manuals/security.html#SSL">http://developer.netscape.com/docs/manuals/security.html#SSL</a>
          </em></li> -->
<li>
<p>Introduction to SSL from Sun ONE Software:<br />
<em><a href="http://www.oracle.com/technetwork/indexes/documentation/index.html">http://docs.sun.com/source/816-6156-10/contents.htm</a></em></p>
</li>
<li>
<p>The SSL Protocol version 3.0 Internet Draft:<br />
<em><a href="http://netscape.aol.com">http://wp.netscape.com/eng/ssl3/ssl-toc.html</a></em></p>
</li>
<li>
<p>The TLS Protocol version 1.0 RFC:<br />
<em><a href=
"http://www.ietf.org/rfc/rfc2246.txt">http://www.ietf.org/rfc/rfc2246.txt</a></em></p>
</li>
<li>
<p>"HTTP Over TLS" Information RFC:<br />
<em><a href=
"http://www.ietf.org/rfc/rfc2818.txt">http://www.ietf.org/rfc/rfc2818.txt</a></em></p>
</li>
</ul>
<p>Books:</p>
<ul>
<li>
<p><em>SSL and TLS: Designing and Building Secure Systems</em> by
Eric Rescorla. Addison Wesley Professional, 2000.</p>
</li>
<li>
<p><em>SSL and TLS Essentials: Securing the Web</em> by Stephen
Thomas. John Wiley and Sons, Inc., 2000.</p>
</li>
<li>
<p><em>Java 2 Network Security</em>, Second Edition, by Marco
Pistoia, Duane F Reller, Deepak Gupta, Milind Nagnur, and Ashok K
Ramani. Prentice Hall, 1999. Copyright 1999 International Business
Machines.</p>
</li>
</ul>
<!-- *********************************************** -->
<a name="Terms" id="Terms"></a>
<h1>Terms and Definitions</h1>
<p>There are several terms relating to cryptography that are used
within this document. This section defines some of these terms.</p>
<h2>Authentication</h2>
<i>Authentication</i> is the process of confirming the identity of
a party with whom one is communicating.
<h2><a name="CipherSuite" id="CipherSuite">Cipher Suite</a></h2>
A <i>cipher suite</i> is a combination of cryptographic parameters
that define the security algorithms and key sizes used for
authentication, key agreement, encryption, and integrity
protection.
<h2>Certificate</h2>
A <i>certificate</i> is a digitally signed statement vouching for
the identity and public key of an entity (person, company, etc.).
Certificates can either be self-signed or issued by a Certification
Authority (CA). Certification Authorities are entities that are
trusted to issue valid certificates for other entities. Well-known
CAs include VeriSign, Entrust, and GTE CyberTrust. X509 is a common
certificate format, and they can be managed by the JDK's keytool.
<h2>Cryptographic Hash Function</h2>
A <i>cryptographic hash function</i> is similar to a checksum. Data
is processed with an algorithm that produces a relatively small
string of bits called a hash. A cryptographic hash function has
three primary characteristics: it is a one-way function, meaning
that it is not possible to produce the original data from the hash;
a small change in the original data produces a large change in the
resulting hash; and it does not require a cryptographic key.
<h2>Cryptographic Service Provider</h2>
In the JCA, implementations for various cryptographic algorithms
are provided by <i>cryptographic service providers</i>, or
"<a href="../crypto/CryptoSpec.html#ProviderArch">providers</a>"
for short. Providers are essentially packages that implement one or
more engine classes for specific algorithms. An engine class
defines a cryptographic service in an abstract fashion without a
concrete implementation.
<h2>Digital Signature</h2>
A <i>digital signature</i> is the digital equivalent of a
handwritten signature. It is used to ensure that data transmitted
over a network was sent by whoever claims to have sent it and that
the data has not been modified in transit. For example, an
RSA-based digital signature is calculated by first computing a
cryptographic hash of the data and then encrypting the hash with
the sender's private key.
<h2>Encryption and Decryption</h2>
<i>Encryption</i> is the process of using a complex algorithm to
convert an original message, or <i>cleartext</i>, to an encoded
message, called <i>ciphertext</i>, that is unintelligible unless it
is decrypted. <i>Decryption</i> is the inverse process of producing
cleartext from ciphertext. The algorithms used to encrypt and
decrypt data typically come in two categories: secret key
(symmetric) cryptography and public key (asymmetric) cryptography.
<h2>Handshake Protocol</h2>
The negotiation phase during which the two socket peers agree to
use a new or existing session. The <i>handshake protocol</i> is a
series of messages exchanged over the record protocol. At the end
of the handshake new connection-specific encryption and integrity
protection keys are generated based on the key agreement secrets in
the session.
<h2>Key Agreement</h2>
<i>Key agreement</i> is a method by which two parties cooperate to
establish a common key. Each side generates some data which is
exchanged. These two pieces of data are then combined to generate a
key. Only those holding the proper private initialization data will
be able to obtain the final key. Diffie-Hellman (DH) is the most
common example of a key agreement algorithm.
<h2>Key Exchange</h2>
One side generates a symmetric key and encrypts it using the peer's
public key (typically RSA). The data is then transmitted to the
peer, who then decrypts the key using its corresponding private
key.
<p><a name="KMandTMdef" id="KMandTMdef"></a></p>
<h2>Key Managers and Trust Managers</h2>
<p><i>Key managers</i> and <i>trust managers</i> use keystores for
their key material. A key manager manages a keystore and supplies
public keys to others as needed, e.g., for use in authenticating
the user to others. A trust manager makes decisions about who to
trust based on information in the truststore it manages.</p>
<a name="Stores" id="Stores"></a>
<h2>Keystores and Truststores</h2>
<p>A <i>keystore</i> is a database of key material. Key material is
used for a variety of purposes, including authentication and data
integrity. There are various types of keystores available,
including "PKCS12" and Oracle's "JKS."</p>
<p>Generally speaking, keystore information can be grouped into two
different categories: key entries and trusted certificate entries.
A key entry consists of an entity's identity and its private key,
and can be used for a variety of cryptographic purposes. In
contrast, a trusted certificate entry only contains a public key in
addition to the entity's identity. Thus, a trusted certificate
entry can not be used where a private key is required, such as in a
<code>javax.net.ssl.KeyManager</code>. In the JDK implementation of
"JKS", a keystore may contain both key entries and trusted
certificate entries.</p>
<p>A <i>truststore</i> is a keystore which is used when making
decisions about what to trust. If you receive some data from an
entity that you already trust, and if you can verify that the
entity is the one it claims to be, then you can assume that the
data really came from that entity.</p>
<p>An entry should only be added to a truststore if the user makes
a decision to trust that entity. By either generating a keypair or
by importing a certificate, the user has given trust to that entry,
and thus any entry in the keystore is considered a trusted
entry.</p>
<p>It may be useful to have two different keystore files: one
containing just your key entries, and the other containing your
trusted certificate entries, including Certification Authority (CA)
certificates. The former contains private information, while the
latter does not. Using two different files instead of a single
keystore file provides for a cleaner separation of the logical
distinction between your own certificates (and corresponding
private keys) and others' certificates. You could provide more
protection for your private keys if you store them in a keystore
with restricted access, while providing the trusted certificates in
a more publicly accessible keystore if needed.</p>
<h2>Message Authentication Code</h2>
A <i>Message Authentication Code</i> (MAC) provides a way to check
the integrity of information transmitted over or stored in an
unreliable medium, based on a secret key. Typically, MACs are used
between two parties that share a secret key in order to validate
information transmitted between these parties.
<p>A MAC mechanism that is based on cryptographic hash functions is
referred to as HMAC. HMAC can be used with any cryptographic hash
function, such as Message Digest 5 (MD5) and Secure Hash Algorithm
(SHA), in combination with a secret shared key. HMAC is specified
in RFC 2104.</p>
<h2>Public Key Cryptography</h2>
<i>Public key cryptography</i> uses an encryption algorithm in
which two keys are produced. One key is made public while the other
is kept private. The public key and the private key are
cryptographic inverses; what one key encrypts only the other key
can decrypt. Public key cryptography is also called asymmetric
cryptography.
<h2>Record Protocol</h2>
The <i>record protocol</i> packages all data whether
application-level or as part of the handshake process into discrete
records of data much like a TCP stream socket converts an
application byte stream into network packets. The individual
records are then protected by the current encryption and integrity
protection keys.
<h2>Secret Key Cryptography</h2>
<i>Secret key cryptography</i> uses an encryption algorithm in
which the same key is used both to encrypt and decrypt the data.
Secret key cryptography is also called symmetric cryptography.
<h2>Session</h2>
A <i>session</i> is a named collection of state information
including authenticated peer identity, cipher suite, and key
agreement secrets which are negotiated through a secure socket
handshake and which can be shared among multiple secure socket
instances.
<h2>Trust Managers</h2>
See <a href="#KMandTMdef">Key Managers and Trust Managers</a>.
<h2>Truststore</h2>
See <a href="#Stores">Keystores and Truststores</a>.<br />
<a name="SSLOverview" id="SSLOverview"></a>
<h1>Secure Sockets Layer (SSL) Protocol Overview</h1>
<p>Secure Sockets Layer (SSL) is the most widely used protocol for
implementing cryptography on the Web. SSL uses a combination of
cryptographic processes to provide secure communication over a
network. This section provides an introduction to SSL and the
cryptographic processes it uses.</p>
<p>SSL provides a secure enhancement to the standard TCP/IP sockets
protocol used for Internet communications. As shown in the
following table, "TCP/IP Protocol Stack with SSL," the secure
sockets layer is added between the transport layer and the
application layer in the standard TCP/IP protocol stack. The
application most commonly used with SSL is Hypertext Transfer
Protocol (HTTP), the protocol for Internet Web pages. Other
applications, such as Net News Transfer Protocol (NNTP), Telnet,
Lightweight Directory Access Protocol (LDAP), Interactive Message
Access Protocol (IMAP), and File Transfer Protocol (FTP), can be
used with SSL as well.</p>
<p>Note: There is currently no standard for secure FTP.</p>
<table border="1" summary="TCP/IP Protocol Stack with SSL">
<caption>TCP/IP Protocol Stack with SSL</caption>
<tbody>
<tr>
<th>TCP/IP Layer</th>
<th>Protocol</th>
</tr>
<tr>
<td>Application Layer</td>
<td>HTTP, NNTP, Telnet, FTP, etc.</td>
</tr>
<tr>
<td>Secure Sockets Layer</td>
<td>SSL</td>
</tr>
<tr>
<td>Transport Layer</td>
<td>TCP</td>
</tr>
<tr>
<td>Internet Layer</td>
<td>IP</td>
</tr>
</tbody>
</table>
<p>SSL was developed by Netscape in 1994, and with input from the
Internet community, has evolved to become a standard. It is now
under the control of the international standards organization, the
Internet Engineering Task Force (IETF). The IETF has renamed SSL to
Transport Layer Security (TLS), and released the first
specification, version 1.0, in January 1999. TLS 1.0 is a modest
upgrade to the most recent version of SSL, version 3.0. The
differences between SSL 3.0 and TLS 1.0 are minor. <a name="WhySSL"
id="WhySSL"></a></p>
<h2>Why Use SSL?</h2>
Transferring sensitive information over a network can be risky due
to the following three issues:
<ul>
<li>You cannot always be sure that the entity with whom you are
communicating is really who you think it is.</li>
<li>Network data can be intercepted, so it is possible that it can
be read by an unauthorized third party, sometimes known as an
attacker.</li>
<li>If an attacker can intercept the data, the attacker may be able
to modify the data before sending it on to the receiver.</li>
</ul>
<p>SSL addresses each of these issues. It addresses the first issue
by optionally allowing each of two communicating parties to ensure
the identity of the other party in a process called authentication.
Once the parties are authenticated, SSL provides an encrypted
connection between the two parties for secure message transmission.
Encrypting the communication between the two parties provides
privacy and therefore addresses the second issue. The encryption
algorithms used with SSL include a secure hash function, which is
similar to a checksum. This ensures that data is not modified in
transit. The secure hash function addresses the third issue of data
integrity.</p>
<p>Note, both authentication and encryption are optional, and
depend on the the negotiated cipher suites between the two
entities.</p>
<p>The most obvious example of when you would use SSL is in an
e-commerce transaction. In an e-commerce transaction, it would be
foolish to assume that you can guarantee the identity of the server
with whom you are communicating. It would be easy enough for
someone to create a phony Web site promising great services if only
you enter your credit card number. SSL allows you, the client, to
authenticate the identity of the server. It also allows the server
to authenticate the identity of the client, although in Internet
transactions, this is seldom done.</p>
<p>Once the client and the server are comfortable with each other's
identity, SSL provides privacy and data integrity through the
encryption algorithms it uses. This allows sensitive information,
such as credit card numbers, to be transmitted securely over the
Internet.</p>
<p>While SSL provides authentication, privacy, and data integrity,
it does not provide non-repudiation services. Non-repudiation means
that an entity that sends a message cannot later deny that they
sent it. When the digital equivalent of a signature is associated
with a message, the communication can later be proved. SSL alone
does not provide non-repudiation.</p>
<a name="HowSSLWorks" id="HowSSLWorks"></a>
<h2>How SSL Works</h2>
One of the reasons SSL is effective is that it uses several
different cryptographic processes. SSL uses public key cryptography
to provide authentication, and secret key cryptography and digital
signatures to provide for privacy and data integrity. Before you
can understand SSL, it is helpful to understand these cryptographic
processes.
<h3>Cryptographic Processes</h3>
The primary purpose of cryptography is to make it difficult for an
unauthorized third party to access and understand private
communication between two parties. It is not always possible to
restrict all unauthorized access to data, but private data can be
made unintelligible to unauthorized parties through the process of
encryption. Encryption uses complex algorithms to convert the
original message, or cleartext, to an encoded message, called
ciphertext. The algorithms used to encrypt and decrypt data that is
transferred over a network typically come in two categories: secret
key cryptography and public key cryptography. These forms of
cryptography are explained in the following subsections.
<p>Both secret key cryptography and public key cryptography depend
on the use of an agreed-upon cryptographic key or pair of keys. A
key is a string of bits that is used by the cryptographic algorithm
or algorithms during the process of encrypting and decrypting the
data. A cryptographic key is like a key for a lock: only with the
right key can you open the lock.</p>
<p>Safely transmitting a key between two communicating parties is
not a trivial matter. A public key certificate allows a party to
safely transmit its public key, while ensuring the receiver of the
authenticity of the public key. Public key certificates are
described in a later section.</p>
<p>In the descriptions of the cryptographic processes that follow,
we use the conventions used by the security community: we label the
two communicating parties with the names Alice and Bob. We call the
unauthorized third party, also known as the attacker, Charlie.</p>
<h4>Secret Key Cryptography</h4>
<p>With secret key cryptography, both communicating parties, Alice
and Bob, use the same key to encrypt and decrypt the messages.
Before any encrypted data can be sent over the network, both Alice
and Bob must have the key and must agree on the cryptographic
algorithm that they will use for encryption and decryption.</p>
<p>One of the major problems with secret key cryptography is the
logistical issue of how to get the key from one party to the other
without allowing access to an attacker. If Alice and Bob are
securing their data with secret key cryptography, and if Charlie
gains access to their key, Charlie can understand any secret
messages he intercepts between Alice and Bob. Not only can Charlie
decrypt Alice's and Bob's messages, but he can also pretend that he
is Alice and send encrypted data to Bob. Bob will not know that the
message came from Charlie, not Alice.</p>
<p>Once the problem of secret key distribution is solved, secret
key cryptography can be a valuable tool. The algorithms provide
excellent security and encrypt data relatively quickly. The
majority of the sensitive data sent in an SSL session is sent using
secret key cryptography.</p>
<p>Secret key cryptography is also called <i>symmetric
cryptography</i> because the same key is used to both encrypt and
decrypt the data. Well-known secret key cryptographic algorithms
include the Data Encryption Standard (DES), triple-strength DES
(3DES), Rivest Cipher 2 (RC2), and Rivest Cipher 4 (RC4).</p>
<h4>Public Key Cryptography</h4>
<p>Public key cryptography solves the logistical problem of key
distribution by using both a public key and a private key. The
public key can be sent openly through the network while the private
key is kept private by one of the communicating parties. The public
and the private keys are cryptographic inverses of each other; what
one key encrypts, the other key will decrypt.</p>
<p>Assume that Bob wants to send a secret message to Alice using
public key cryptography. Alice has both a public key and a private
key, so she keeps her private key in a safe place and sends her
public key to Bob. Bob encrypts the secret message to Alice using
Alice's public key. Alice can later decrypt the message with her
private key.</p>
<p>If Alice encrypts a message using her private key and sends the
encrypted message to Bob, Bob can be sure that the data he receives
comes from Alice; if Bob can decrypt the data with Alice's public
key, the message must have been encrypted by Alice with her private
key, and only Alice has Alice's private key. The problem is that
anybody else can read the message as well because Alice's public
key is public. While this scenario does not allow for secure data
communication, it does provide the basis for digital signatures. A
digital signature is one of the components of a public key
certificate, and is used in SSL to authenticate a client or a
server. Public key certificates and digital signatures are
described in later sections.</p>
<p>Public key cryptography is also called <i>asymmetric
cryptography</i> because different keys are used to encrypt and
decrypt the data. A well known public key cryptographic algorithm
often used with SSL is the Rivest Shamir Adleman (RSA) algorithm.
Another public key algorithm used with SSL that is designed
specifically for secret key exchange is the Diffie-Hellman (DH)
algorithm. Public key cryptography requires extensive computations,
making it very slow. It is therefore typically used only for
encrypting small pieces of data, such as secret keys, rather than
for the bulk of encrypted data communications.</p>
<h4>A Comparison Between Secret Key and Public Key
Cryptography</h4>
<p>Both secret key cryptography and public key cryptography have
strengths and weaknesses. With secret key cryptography, data can be
encrypted and decrypted quickly, but because both communicating
parties must share the same secret key information, the logistics
of exchanging the key can be a problem. With public key
cryptography, key exchange is not a problem because the public key
does not need to be kept secret, but the algorithms used to encrypt
and decrypt data require extensive computations, and are therefore
very slow.</p>
<h4>Public Key Certificates</h4>
<p>A public key certificate provides a safe way for an entity to
pass on its public key to be used in asymmetric cryptography. The
public key certificate avoids the following situation: if Charlie
creates his own public key and private key, he can claim that he is
Alice and send his public key to Bob. Bob will be able to
communicate with Charlie, but Bob will think that he is sending his
data to Alice.</p>
<p>A public key certificate can be thought of as the digital
equivalent of a passport. It is issued by a trusted organization
and provides identification for the bearer. A trusted organization
that issues public key certificates is known as a certificate
authority (CA). The CA can be likened to a notary public. To obtain
a certificate from a CA, one must provide proof of identity. Once
the CA is confident that the applicant represents the organization
it says it represents, the CA signs the certificate attesting to
the validity of the information contained within the
certificate.</p>
<p>A public key certificate contains several fields, including:</p>
<ul>
<li>Issuer - The issuer is the CA that issued the certificate. If a
user trusts the CA that issues a certificate, and if the
certificate is valid, the user can trust the certificate.</li>
<li>Period of validity - A certificate has an expiration date, and
this date is one piece of information that should be checked when
verifying the validity of a certificate.</li>
<li>Subject - The subject field includes information about the
entity that the certificate represents.</li>
<li>Subject's public key - The primary piece of information that
the certificate provides is the subject's public key. All the other
fields are provided to ensure the validity of this key.</li>
<li>Signature - The certificate is digitally signed by the CA that
issued the certificate. The signature is created using the CA's
private key and ensures the validity of the certificate. Because
only the certificate is signed, not the data sent in the SSL
transaction, SSL does not provide for non-repudiation.</li>
</ul>
<p>If Bob only accepts Alice's public key as valid when she sends
it in a public key certificate, Bob will not be fooled into sending
secret information to Charlie when Charlie masquerades as
Alice.</p>
<p>Multiple certificates may be linked in a certificate chain. When
a certificate chain is used, the first certificate is always that
of the sender. The next is the certificate of the entity that
issued the sender's certificate. If there are more certificates in
the chain, each is that of the authority that issued the previous
certificate. The final certificate in the chain is the certificate
for a root CA. A root CA is a public certificate authority that is
widely trusted. Information for several root CAs is typically
stored in the client's Internet browser. This information includes
the CA's public key. Well-known CAs include VeriSign, Entrust, and
GTE CyberTrust.</p>
<h4>Cryptographic Hash Functions</h4>
<p>When sending encrypted data, SSL typically uses a cryptographic
hash function to ensure data integrity. The hash function prevents
Charlie from tampering with data that Alice sends to Bob.</p>
<p>A cryptographic hash function is similar to a checksum. The main
difference is that while a checksum is designed to detect
accidental alterations in data, a cryptographic hash function is
designed to detect deliberate alterations. When data is processed
by a cryptographic hash function, a small string of bits, known as
a hash, is generated. The slightest change to the message typically
makes a large change in the resulting hash. A cryptographic hash
function does not require a cryptographic key. Two hash functions
often used with SSL are Message Digest 5 (MD5) and Secure Hash
Algorithm (SHA). SHA was proposed by the <a href="http://www.nist.gov/index.html">U.S. National Institute of Science and
Technology (NIST)</a>.</p>
<h4>Message Authentication Code</h4>
A message authentication code (MAC) is similar to a cryptographic
hash, except that it is based on a secret key. When secret key
information is included with the data that is processed by a
cryptographic hash function, the resulting hash is known as an
HMAC.
<p>If Alice wants to be sure that Charlie does not tamper with her
message to Bob, she can calculate an HMAC for her message and
append the HMAC to her original message. She can then encrypt the
message plus the HMAC using a secret key she shares with Bob. When
Bob decrypts the message and calculates the HMAC, he will be able
to tell if the message was modified in transit. With SSL, an HMAC
is used with the transmission of secure data.</p>
<h4>Digital Signatures</h4>
<p>Once a cryptographic hash is created for a message, the hash is
encrypted with the sender's private key. This encrypted hash is
called a digital signature.</p>
<a name="SSLProcess" id="SSLProcess"></a>
<h3>The SSL Process</h3>
<p>Communication using SSL begins with an exchange of information
between the client and the server. This exchange of information is
called the SSL handshake.</p>
<p>The three main purposes of the SSL handshake are:</p>
<ul>
<li>Negotiate the cipher suite</li>
<li>Authenticate identity (optional)</li>
<li>Establish information security by agreeing on encryption
mechanisms</li>
</ul>
<h4>Negotiating the Cipher Suite</h4>
<p>The SSL session begins with a negotiation between the client and
the server as to which cipher suite they will use. A cipher suite
is a set of cryptographic algorithms and key sizes that a computer
can use to encrypt data. The cipher suite includes information
about the public key exchange algorithms or key agreement
algorithms, and cryptographic hash functions. The client tells the
server which cipher suites it has available, and the server chooses
the best mutually acceptable cipher suite.</p>
<h4>Authenticating the Server</h4>
<p>In SSL, the authentication step is optional, but in the example
of an e-commerce transaction over the Web, the client will
generally want to authenticate the server. Authenticating the
server allows the client to be sure that the server represents the
entity that the client believes the server represents.</p>
<p>To prove that a server belongs to the organization that it
claims to represent, the server presents its public key certificate
to the client. If this certificate is valid, the client can be sure
of the identity of the server.</p>
<p>The client and server exchange information that allows them to
agree on the same secret key. For example, with RSA, the client
uses the server's public key, obtained from the public key
certificate, to encrypt the secret key information. The client
sends the encrypted secret key information to the server. Only the
server can decrypt this message because the server's private key is
required for this decryption.</p>
<h4>Sending the Encrypted Data</h4>
<p>Both the client and the server now have access to the same
secret key. With each message, they use the cryptographic hash
function, chosen in the first step of this process, and shared
secret information, to compute an HMAC that they append to the
message. They then use the secret key and the secret key algorithm
negotiated in the first step of this process to encrypt the secure
data and the HMAC. The client and server can now communicate
securely using their encrypted and hashed data.</p>
<h3>The SSL Protocol</h3>
<p>The previous section provides a high-level description of the
SSL handshake, which is the exchange of information between the
client and the server prior to sending the encrypted message. This
section provides more detail.</p>
<p>The "SSL Messages" figure that follows shows the sequence of
messages that are exchanged in the SSL handshake. Messages that are
sent only in certain situations are noted as optional. Each of the
SSL messages is described in the following figure:<br />
<br /></p>
<img src="sslmessages.gif" width="484" height="418" alt=
"Sequence of messages exchanged in SSL handshake." /><br />
<br />
<br />
<p>The SSL messages are sent in the following order:</p>
<ol>
<li><b>Client hello</b> - The client sends the server information
including the highest version of SSL it supports and a list of the
cipher suites it supports. (TLS 1.0 is indicated as SSL 3.1.) The
cipher suite information includes cryptographic algorithms and key
sizes.</li>
<li><b>Server hello</b> - The server chooses the highest version of
SSL and the best cipher suite that both the client and server
support and sends this information to the client.</li>
<li><b>Certificate</b> - The server sends the client a certificate
or a certificate chain. A certificate chain typically begins with
the server's public key certificate and ends with the certificate
authority's root certificate. This message is optional, but is used
whenever server authentication is required.</li>
<li><b>Certificate request</b> - If the server needs to
authenticate the client, it sends the client a certificate request.
In Internet applications, this message is rarely sent.</li>
<li><b>Server key exchange</b> - The server sends the client a
server key exchange message when the public key information sent in
message 3 above is not sufficient for key exchange. For example, in
ciphersuites based on Diffie-Hellman, this message contains the
server's DH public key.</li>
<li><b>Server hello done</b> - The server tells the client that it
is finished with its initial negotiation messages.</li>
<li><b>Certificate</b> - If the server requests a certificate from
the client in message 4, the client sends its certificate chain,
just as the server did in message 3.
<p>Note: Only a few Internet server applications ask for a
certificate from the client.</p>
</li>
<li><b>Client key exchange</b> - The client generates information
used to create a key to use for symmetric encryption. For RSA, the
client then encrypts this key information with the server's public
key and sends it to the server. For ciphersuites based on
Diffie-Hellman, this message contains the client's DH public
key.</li>
<li><b>Certificate verify</b> - This message is sent when a client
presents a certificate as previously explained. Its purpose is to
allow the server to complete the process of authenticating the
client. When this message is used, the client sends information
that it digitally signs using a cryptographic hash function. When
the server decrypts this information with the client's public key,
the server is able to authenticate the client.</li>
<li><b>Change cipher spec</b> - The client sends a message telling
the server to change to encrypted mode.</li>
<li><b>Finished</b> - The client tells the server that it is ready
for secure data communication to begin.</li>
<li><b>Change cipher spec</b> - The server sends a message telling
the client to change to encrypted mode.</li>
<li><b>Finished</b> - The server tells the client that it is ready
for secure data communication to begin. This is the end of the SSL
handshake.</li>
<li><b>Encrypted data</b> - The client and the server communicate
using the symmetric encryption algorithm and the cryptographic hash
function negotiated in messages 1 and 2, and using the secret key
that the client sent to the server in Message 8. The handshake can
be renegotiated at this time. See the next section for
details.</li>
<li><b>Close Messages</b> - At the end of the connection, each side
will send a <code>close_notify message</code> to inform the peer
that the connection is closed.</li>
</ol>
<p>If the parameters generated during an SSL session are saved,
these parameters can sometimes be reused for future SSL sessions.
Saving SSL session parameters allows encrypted communication to
begin much more quickly.<br /></p>
<h4>Handshaking Again (Renegotiation)</h4>
<p>Once the initial handshake has been finished and application
data is flowing, either side is free to initiate a new handshake at
any time. An application might like to use a stronger cipher suite
for especially critical operations, or a server application might
want to require client authentication.</p>
<p>Regardless of the reason, the new handshake takes place over the
existing encrypted session, and application data and handshake
messages are interleaved until a new session is established.</p>
<p>Your application can initiate a new handshake using one of the
following methods:</p>
<ul>
<li><code>SSLSocket.startHandshake()</code></li>
<li><code>SSLEngine.beginHandshake()</code></li>
</ul>
<p>Note that a protocol flaw related to renegotiation was found in
2009. The protocol and the Java SE implementation have both been
fixed. For more information, see <a href=
"#tlsRenegotiation">Transport Layer Security (TLS) Renegotiation
Issue</a>.</p>
<a name="ciphersuitechoice" id="ciphersuitechoice"></a>
<h4>Cipher Suite Choice and Remote Entity Verification</h4>
The <a href="#SSLDocs">SSL/TLS protocols</a> define a specific
series of steps to ensure a "protected" connection. However, the
choice of cipher suite will directly impact the type of security
the connection enjoys. For example, if an anonymous cipher suite is
selected, the application will have no way to verify the remote
peer's identity. If a suite with no encryption is selected, then
the privacy of the data can not be protected. Additionally, the
SSL/TLS protocols do not specify that the credentials received must
match those that peer might be expected to send. If the connection
were somehow redirected to a rogue peer, but the rogue's
credentials presented were acceptable based on the current trust
material, the connection would be considered valid.
<p>When using raw <code>SSLSockets/SSLEngines</code> you should
always check the peer's credentials before sending any data. The
<code>SSLSocket</code> and <code>SSLEngine</code> classes do not
automatically verify that the hostname in a URL matches the
hostname in the peer's credentials. An application could be
exploited with URL spoofing if the hostname is not verified.</p>
<p>Protocols such as <a href=
"http://www.ietf.org/rfc/rfc2818.txt">https</a> do require hostname
verification. Applications can use <a href=
"#HostnameVerifier"><code>HostnameVerifier</code></a> to override
the default HTTPS hostname rules. See <a href=
"#HttpsURLConnection"><code>HttpsURLConnection</code></a> for more
information.<br /></p>
<a name="SSLRefs" id="SSLRefs"></a>
<h2>SSL and TLS References</h2>
<p>For a list of resources containing more information about SSL,
see <a href="#SSLDocs">Secure Sockets Layer Documentation</a> .</p>
<a name="KeyClasses" id="KeyClasses"></a>
<h1>Key Classes</h1>
<a name="ClassRelationship" id="ClassRelationship"></a>
<h2>Relationship Between Classes</h2>
<p>To communicate securely, both sides of the connection must be
SSL-enabled. In the JSSE API, the endpoint classes of the
connection is the <code>SSLSocket</code> and
<code>SSLEngine</code>. In the diagram below, the major classes
used to create <code>SSLSocket/SSLEngine</code>s are laid out in a
logical ordering.<br />
<br /></p>
<img src="classes1.jpg" width="581" height="429" alt=
"diagram of classes used to create SSLSockets/SSLEngines" /><br />
<br />
<br />
<p>An <code>SSLSocket</code> is created either by an
<code>SSLSocketFactory</code> or by an <code>SSLServerSocket</code>
accepting an in-bound connection. (In turn, an
<code>SSLServerSocket</code> is created by an
<code>SSLServerSocketFactory</code>.) Both
<code>SSLSocketFactory</code> and
<code>SSLServerSocketFactory</code> objects are created by an
<code>SSLContext</code>. An <code>SSLEngine</code> is created
directly by the SSLContext, and relies on the application to handle
all I/O.</p>
<hr />
<b>IMPORTANT NOTE:</b> When using raw
<code>SSLSockets/SSLEngines</code> you should always check the
peer's credentials before sending any data. The
<code>SSLSocket/SSLEngine</code> classes do not automatically
verify, for example, that the hostname in a URL matches the
hostname in the peer's credentials. An application could be
exploited with URL spoofing if the hostname is not verified.<br />
<hr />
<p>There are two ways to obtain and initialize an
<code>SSLContext</code>:</p>
<ul>
<li>The simplest is to call the static <code>getDefault</code>
method on either the <code>SSLSocketFactory</code> or
<code>SSLServerSocketFactory</code> class. These methods create a
default <code>SSLContext</code> with a default
<code>KeyManager</code>, <code>TrustManager</code>, and a secure
random number generator. (A default <code>KeyManagerFactory</code>
and <code>TrustManagerFactory</code> are used to create the
<code>KeyManager</code> and <code>TrustManager</code>,
respectively.) The key material used is found in the default
keystore/truststore, as determined by system properties described
in <a href="#CustomizingStores">Customizing the Default Key and
Trust Stores, Store Types, and Store Passwords</a>.</li>
<li>The approach that gives the caller the most control over the
behavior of the created context is to call the static method
<code>getInstance</code> on the <code>SSLContext</code> class, then
initialize the context by calling the instance's proper
<code>init</code> method. One variant of the <code>init</code>
method takes three arguments: an array of <code>KeyManager</code>
objects, an array of <code>TrustManager</code> objects, and a
<code>SecureRandom</code> random number generator. The
<code>KeyManager</code> and <code>TrustManager</code> objects are
created by either implementing the appropriate interface(s) or
using the <code>KeyManagerFactory</code> and
<code>TrustManagerFactory</code> classes to generate
implementations. The <code>KeyManagerFactory</code> and
<code>TrustManagerFactory</code> can then each be initialized with
key material contained in the <code>KeyStore</code> passed as an
argument to the <code>TrustManagerFactory/KeyManagerFactory</code>
<code>init</code> method. Finally, the
<code>getTrustManagers</code> method (in
<code>TrustManagerFactory</code>) and <code>getKeyManagers</code>
method (in <code>KeyManagerFactory</code>) can be called to obtain
the array of trust or key managers, one for each type of trust or
key material.</li>
</ul>
<p>Once an SSL connection is established, an
<code>SSLSession</code> is created which contains various
information, such as identities established, cipher suite used,
etc. The <code>SSLSession</code> is then used to describe an
ongoing relationship and state information between two entities.
Each SSL connection involves one session at a time, but that
session may be used on many connections between those entities,
simultaneously or sequentially.</p>
<a name="CoreClasses" id="CoreClasses"></a>
<h2>Core Classes and Interfaces</h2>
<p>The core JSSE classes are part of the <code>javax.net</code> and
<code>javax.net.ssl</code> packages. <a name="SocketFactory" id=
"SocketFactory"></a></p>
<h3><code>SocketFactory</code> and <code>ServerSocketFactory</code>
Classes</h3>
<p>The abstract <code>javax.net.SocketFactory</code> class is used
to create sockets. It must be subclassed by other factories, which
create particular subclasses of sockets and thus provide a general
framework for the addition of public socket-level functionality.
(See, for example, <a href=
"#SSLSocketFactory"><code>SSLSocketFactory</code></a>.)</p>
<p>The <code>javax.net.ServerSocketFactory</code> class is
analogous to the <code>SocketFactory</code> class, but is used
specifically for creating server sockets.</p>
<p>Socket factories are a simple way to capture a variety of
policies related to the sockets being constructed, producing such
sockets in a way which does not require special configuration of
the code which asks for the sockets:</p>
<ul>
<li>Due to polymorphism of both factories and sockets, different
kinds of sockets can be used by the same application code just by
passing different kinds of factories.</li>
<li>Factories can themselves be customized with parameters used in
socket construction. So for example, factories could be customized
to return sockets with different networking timeouts or security
parameters already configured.</li>
<li>The sockets returned to the application can be subclasses of
<code>java.net.Socket</code> (or
<code>javax.net.ssl.SSLSocket</code>), so that they can directly
expose new APIs for features such as compression, security, record
marking, statistics collection, or firewall tunneling.</li>
</ul>
<a name="SSLSocketFactory" id="SSLSocketFactory"></a>
<h3><code>SSLSocketFactory</code> and
<code>SSLServerSocketFactory</code> Classes</h3>
<p>A <code>javax.net.ssl.SSLSocketFactory</code> acts as a factory
for creating secure sockets. This class is an abstract subclass of
<a href=
"#SocketFactory"><code>javax.net.SocketFactory</code></a>.</p>
<p>Secure socket factories encapsulate the details of creating and
initially configuring secure sockets. This includes authentication
keys, peer certificate validation, enabled cipher suites and the
like.</p>
<p>The <code>javax.net.ssl.SSLServerSocketFactory</code> class is
analogous to the <code>SSLSocketFactory</code> class, but is used
specifically for creating server sockets.</p>
<h4>Obtaining an <code>SSLSocketFactory</code></h4>
<p>There are three primary ways of obtaining an
<code>SSLSocketFactory</code>:</p>
<ul>
<li>Get the default factory by calling the
<code>SSLSocketFactory.getDefault</code> static method.</li>
<li>Receive a factory as an API parameter. That is, code which
needs to create sockets but which doesn't care about the details of
how the sockets are configured can include a method with an
<code>SSLSocketFactory</code> parameter that can be called by
clients to specify which <code>SSLSocketFactory</code> to use when
creating sockets. (For example,
javax.net.ssl.HttpsURLConnection.)</li>
<li>Construct a new factory with specifically configured
behavior.</li>
</ul>
<p>The default factory is typically configured to support server
authentication only so that sockets created by the default factory
do not leak any more information about the client than a normal TCP
socket would.</p>
<p>Many classes which create and use sockets do not need to know
the details of socket creation behavior. Creating sockets through a
socket factory passed in as a parameter is a good way of isolating
the details of socket configuration, and increases the reusability
of classes which create and use sockets.</p>
<p>You can create new socket factory instances either by
implementing your own socket factory subclass or by using another
class which acts as a factory for socket factories. One example of
such a class is <code>SSLContext</code>, which is provided with the
JSSE implementation as a provider-based configuration class.</p>
<a name="SSLSocket" id="SSLSocket"></a>
<h3><code>SSLSocket</code> and <code>SSLServerSocket</code>
Classes</h3>
<p>The <code>javax.net.ssl.SSLSocket</code> class is a subclass of
the standard Java <code>java.net.Socket</code> class. It supports
all of the standard socket methods and adds additional methods
specific to secure sockets. Instances of this class encapsulate the
<a href="#SSLContext"><code>SSLContext</code></a> under which they
were created. There are APIs to control the creation of secure
socket sessions for a socket instance but trust and key management
are not directly exposed.</p>
<p>The <code>javax.net.ssl.SSLServerSocket</code> class is
analogous to the <code>SSLSocket</code> class, but is used
specifically for creating server sockets.<br /></p>
<p>To prevent peer spoofing, you should always <a href=
"#ciphersuitechoice">verify the credentials</a> presented to a
SSLSocket.</p>
<p>Implementation note: Due to the complexity of the SSL and TLS
protocols, it is difficult to predict whether incoming bytes on a
connection are handshake or application data, and how that data
might affect the current connection state (even causing the process
to block). In the Oracle JSSE implementation, the
<code>available()</code> method on the object obtained by
<code>SSLSocket.getInputStream()</code> returns a count of the
number of application data bytes successfully decrypted from the
SSL connection but not yet read by the application.</p>
<h4>Obtaining an <code>SSLSocket</code></h4>
Instances of <code>SSLSocket</code> can be obtained in two ways.
First, an <code>SSLSocket</code> can be created by an instance of
<a href="#SSLSocketFactory"><code>SSLSocketFactory</code></a> via
one of the several <code>createSocket</code> methods on that class.
The second way to obtain <code>SSLSocket</code>s is through the
<code>accept</code> method on the <code>SSLServerSocket</code>
class. <a name="SSLENG" id="SSLENG"></a>
<h3>Nonblocking I/O with <code>SSLEngine</code></h3>
SSL/TLS is becoming increasingly popular. It is being used in a
wide variety of applications across a wide range of computing
platforms and devices. Along with this popularity comes demands to
use it with different I/O and threading models in order to satisfy
the applications' performance, scalability, footprint, and other
requirements. There are demands to use it with blocking and
nonblocking I/O channels, asynchronous I/O, arbitrary input and
output streams, and byte buffers. There are demands to use it in
highly scalable, performance-critical environments, requiring
management of thousands of network connections.
<p>Prior to Java SE 5, the JSSE API supported only a single
transport abstraction: stream-based sockets via SSLSocket. While
this was adequate for many applications, it did not meet the needs
of applications that need to use different I/O or threading models.
In 1.6.0, a new abstraction was introduced to allow applications to
use the SSL/TLS protocols in a transport independent way, and thus
freeing applications to choose transport and computing models that
best meet their needs. Not only does this new abstraction allow
applications to use nonblocking I/O channels and other I/O models,
it also accommodates different threading models. This effectively
leaves the I/O and threading decisions up to the application.
Because of this flexibility, the application must now manage I/O
and threading (complex topics in and of themselves), as well as
have some understanding of the SSL/TLS protocols. The new
abstraction is therefore an advanced API: beginners should continue
to use <tt>SSLSocket</tt>.</p>
<p>Newcomers to the API may wonder "Why not just have an
<code>SSLSocketChannel</code> which extends
<code>java.nio.channels.SocketChannel</code>?" There are two main
reasons:</p>
<ul>
<li>There were a lot of very difficult questions about what a
<code>SSLSocketChannel</code> should be, including its class
hierarchy and how it should interoperate with
<code>Selector</code>s and other types of
<code>SocketChannel</code>s. Each proposal brought up more
questions than answers. It was noted that any new API abstraction
extended to work with SSL/TLS would require the same significant
analysis and could result in large and complex APIs.</li>
<li>Any JSSE implementation of a new API would be free to choose
the "best" I/O &amp; compute strategy, but hiding any of these
details is inappropriate for those applications needing full
control. Any specific implementation would be inappropriate for
some application segment.</li>
</ul>
By abstracting the I/O and treating data as streams of bytes, these
issues are resolved and the new API could be used with any existing
or future I/O model. While this solution makes I/O and CPU handling
the developers' responsibility, JSSE implementations are prevented
from being unusable due to some unconfigurable and/or unchangeable
internal detail.
<p>Users of other Java programming language APIs such as JGSS and
SASL will notice similarities in that the application is also
responsible for transporting data.</p>
<h3><code>SSLEngine</code></h3>
The core class in this new abstraction is <a href=
"../../../../api/javax/net/ssl/SSLEngine.html"><tt>javax.net.ssl.SSLEngine</tt></a>.
It encapsulates an SSL/TLS state machine and operates on inbound
and outbound byte buffers supplied by the user of the
<tt>SSLEngine</tt>. The following diagram illustrates the flow of
data from the application, to the <tt>SSLEngine</tt>, to the
transport mechanism, and back. <!-- PICTURE -->
<p class="c1"><img src="sslengine.jpg" align="top" border="0" alt=
"SSLEngine" /></p>
<!--<tt>SSLEngine.wrap()</tt> and <tt>SSLEngine.unwrap()</tt> are the
only methods by which to get data into and out of the engine
-->
The application, shown on the left, supplies application
(plaintext) data in an application buffer and passes it to the
<tt>SSLEngine</tt>. The <tt>SSLEngine</tt> processes the data
contained in the buffer, or any handshaking data, to produce
SSL/TLS encoded data and places it the network buffer supplied by
the application. The application is then responsible for using an
appropriate transport (shown on the right) to send the contents of
the network buffer to its peer. Upon receiving SSL/TLS encoded data
from its peer (via the transport), the application places the data
into a network buffer and passes it to <tt>SSLEngine</tt>. The
<tt>SSLEngine</tt> processes the network buffer's contents to
produce handshaking data or application data. 
<!-- If the application were to choose a stream-based socket as the
transport mechanism, then this overview more or less corresponds to
how an application would <tt>SSLSocket</tt>s except that with the new
abstraction, it is doing each exchange in two steps instead of one.
-->
<!--
<p>
The TLS (and SSL) protocol is actually a collection of protocols.  One
protocol supports application data exchange while the others support
authentication, negotiation of the use of cipher suites and other
parameters, and communication of warnings and errors.  These
non-application data exchange tasks are referred to as
<em>handshaking</em> and affect the state of the <tt>SSLEngine</tt>.
When handshaking data is fed to the <tt>SSLEngine</tt> (encapsulated
within SSL/TLS encoded data received from the peer), it might change
the engine's state such that the engine cannot process any more
application data until it completes the handshaking.
-->
<p>In all, <tt>SSLEngine</tt> can be in one of five states.</p>
<ol>
<li>Creation - ready to be configured.</li>
<li>Initial handshaking - perform authentication and negotiate
communication parameters.</li>
<li>Application data - ready for application exchange.</li>
<li>Rehandshaking - renegotiate communications
parameters/authentication; handshaking data may be mixed with
application data.</li>
<li>Closure - ready to shut down connection.</li>
</ol>
These five states are described in more detail in the <a href=
"../../../../api/javax/net/ssl/SSLEngine.html"><tt>SSLEngine</tt></a>
class documentation.
<h3>Getting Started</h3>
To create an <tt>SSLEngine</tt>, you use the
<tt>SSLContext.createSSLEngine()</tt> methods. You must then
configure the engine to act as a client or a server, as well as set
other configuration parameters such as which cipher suites to use
and whether to require client authentication.
<p>Here is an example that creates an <tt>SSLEngine</tt>. Note that
the server name and port number are not used for communicating with
the server--all transport is the responsibility of the application.
They are hints to the JSSE provider to use for SSL session caching,
and for Kerberos-based cipher suite implementations to determine
which server credentials should be obtained.</p>
<pre class="codeblock">
import javax.net.ssl.*;
import java.security.*;

// Create/initialize the SSLContext with key material

char[] passphrase = "passphrase".toCharArray();

// First initialize the key and trust material.
KeyStore ksKeys = KeyStore.getInstance("JKS");
ksKeys.load(new FileInputStream("testKeys"), passphrase);
KeyStore ksTrust = KeyStore.getInstance("JKS");
ksTrust.load(new FileInputStream("testTrust"), passphrase);

// KeyManager's decide which key material to use.
KeyManagerFactory kmf =
    KeyManagerFactory.getInstance("SunX509");
kmf.init(ksKeys, passphrase);

// TrustManager's decide whether to allow connections.
TrustManagerFactory tmf =
    TrustManagerFactory.getInstance("SunX509");
tmf.init(ksTrust);

sslContext = SSLContext.getInstance("TLS");
sslContext.init(
    kmf.getKeyManagers(), tmf.getTrustManagers(), null);

// We're ready for the engine.
SSLEngine engine = sslContext.createSSLengine(hostname, port);

// Use as client
engine.setUseClientMode(true);
</pre>
<h3>Generating and Processing SSL/TLS data</h3>
The two main <tt>SSLEngine</tt> methods <tt>wrap()</tt> and
<tt>unwrap()</tt> are responsible for generating and consuming
network data respectively. Depending on the state of the
<tt>SSLEngine</tt>, this data might be handshake or application
data.
<p>Each <tt>SSLEngine</tt> has several phases during its lifetime.
Before application data can be sent/received, the SSL/TLS protocol
requires a handshake to establish cryptographic parameters. This
handshake requires a series of back-and-forth steps by the
<tt>SSLEngine</tt>. <a href="#SSLProcess">The SSL Process</a> can
provide more details about the handshake itself.</p>
<p>During the initial handshaking, <tt>wrap()</tt> and
<tt>unwrap()</tt> generate and consume handshake data, and the
application is responsible for transporting the data. The
<tt>wrap()</tt>/<tt>unwrap()</tt> sequence is repeated until the
handshake is finished. Each <tt>SSLEngine</tt> operation generates
a <tt>SSLEngineResult</tt>, of which the
<tt>SSLEngineResult.HandshakeStatus</tt> field is used to determine
what operation needs to occur next to move the handshake along.</p>
<p>A typical handshake might look like this:</p>
<table summary="Typical handshake" border="1">
<tr>
<td><b><code>client</code></b></td>
<td><b><code>SSL/TLS message</code></b></td>
<td><b><code>HSStatus</code></b></td>
</tr>
<tr>
<td><code>wrap()</code></td>
<td><code>ClientHello</code></td>
<td><code>NEED_UNWRAP</code></td>
</tr>
<tr>
<td><code>unwrap()</code></td>
<td><code>ServerHello/Cert/ServerHelloDone</code></td>
<td><code>NEED_WRAP</code></td>
</tr>
<tr>
<td><code>wrap()</code></td>
<td><code>ClientKeyExchange</code></td>
<td><code>NEED_WRAP</code></td>
</tr>
<tr>
<td><code>wrap()</code></td>
<td><code>ChangeCipherSpec</code></td>
<td><code>NEED_WRAP</code></td>
</tr>
<tr>
<td><code>wrap()</code></td>
<td><code>Finished</code></td>
<td><code>NEED_UNWRAP</code></td>
</tr>
<tr>
<td><code>unwrap()</code></td>
<td><code>ChangeCipherSpec</code></td>
<td><code>NEED_UNWRAP</code></td>
</tr>
<tr>
<td><code>unwrap()</code></td>
<td><code>Finished</code></td>
<td><code>FINISHED</code></td>
</tr>
</table>
Now that handshaking is complete, further calls to <tt>wrap()</tt>
will attempt to consume application data and packages it for
transport. <tt>unwrap()</tt> attempts the opposite.
<p>To send data to the peer, the application first supplies the
data that it wants to send to <tt>SSLEngine</tt> via
<tt>SSLEngine.wrap()</tt> to obtain the corresponding SSL/TLS
encoded data. The application then sends the encoded data to the
peer using its chosen transport mechanism. When the application
receives the SSL/TLS encoded data from the peer via the transport
mechanism, it supplies this data to the <tt>SSLEngine</tt> via
<tt>SSLEngine.unwrap()</tt> to obtain the plaintext data sent by
the peer.</p>
<p>Here is an example of an SSL application that is using a
nonblocking <tt>SocketChannel</tt> to communicate with its peer.
(It can be made more robust and scalable by using a
<tt>Selector</tt> with the nonblocking <tt>SocketChannel</tt>.) The
following sample code sends the string <tt>"hello"</tt> to its
peer, by encoding it using the <tt>SSLEngine</tt> created in the
previous example. It uses information from the <tt>SSLSession</tt>
to determine how large to make the byte buffers.</p>
<pre class="codeblock">
// Create a nonblocking socket channel
SocketChannel socketChannel = SocketChannel.open();
socketChannel.configureBlocking(false);
socketChannel.connect(new InetSocketAddress(hostname, port));

// Complete connection
while (!socketChannel.finishedConnect()) {
    // do something until connect completed
}

// Create byte buffers to use for holding application and encoded data
SSLSession session = engine.getSession();
ByteBuffer myAppData = ByteBuffer.allocate(session.getApplicationBufferSize());
ByteBuffer myNetData = ByteBuffer.allocate(session.getPacketBufferSize());
ByteBuffer peerAppData = ByteBuffer.allocate(session.getApplicationBufferSize());
ByteBuffer peerNetData = ByteBuffer.allocate(session.getPacketBufferSize());

// Do initial handshake
doHandshake(socketChannel, engine, myNetData, peerNetData);

myAppData.put("hello".getBytes());
myAppData.flip();

while (myAppData.hasRemaining()) {
    // Generate SSL/TLS encoded data (handshake or application data)
    SSLEngineResult res = engine.wrap(myAppData, myNetData);

    // Process status of call
    if (res.getStatus() == SSLEngineResult.Status.OK) {
        myAppData.compact();

        // Send SSL/TLS encoded data to peer
        while(myNetData.hasRemaining()) {
            int num = socketChannel.write(myNetData);
            if (num == 0) {
                // no bytes written; try again later
            }
        }
    }

    // Handle other status:  BUFFER_OVERFLOW, CLOSED
    ...
}

</pre>
The following code reads data from the same nonblocking
<tt>SocketChannel</tt> and extracts the plaintext data from it by
using the <tt>SSLEngine</tt> created previously. Each iteration of
this code may or may not produce any plaintext data, depending on
whether handshaking is in progress.
<pre class="codeblock">
// Read SSL/TLS encoded data from peer
int num = socketChannel.read(peerNetData);
if (num == -1) {
    // The channel has reached end-of-stream
} else if (num == 0) {
    // No bytes read; try again ...
} else {
    // Process incoming data
    peerNetData.flip();
    res = engine.unwrap(peerNetData, peerAppData);

    if (res.getStatus() == SSLEngineResult.Status.OK) {
        peerNetData.compact();

        if (peerAppData.hasRemaining()) {
            // Use peerAppData
        }
    }
    // Handle other status:  BUFFER_OVERFLOW, BUFFER_UNDERFLOW, CLOSED
    ...
}
</pre>
<a name="OperationStatus" id="OperationStatus"></a>
<h3>Status of Operations</h3>
To indicate the status of the engine and what action(s) the
application should take, the <tt>SSLEngine.wrap()</tt> and
<tt>SSLEngine.unwrap()</tt> methods return an <a href=
"../../../../api/javax/net/ssl/SSLEngineResult.html"><tt>SSLEngineResult</tt></a>
instance, as shown in the previous examples. The
<tt>SSLEngineResult</tt> contains two pieces of status information:
the overall status of the engine and the handshaking status.
<p>The possible overall statuses are represented by the
<tt>SSLEngineResult.Status</tt> enum. Some examples of this status
include <tt>OK</tt>, which means that there was no error, and
<tt>BUFFER_UNDERFLOW</tt>, which means that the input buffer had
insufficient data, indicating that the application needs to obtain
more data from the peer (for example, by reading more data from the
network), and <tt>BUFFER_OVERFLOW</tt>, which means that the output
buffer had insufficient space to hold the result, indicating that
the application needs to clear or enlarge the destination
buffer.</p>
<p>Here is an example of how to handle <tt>BUFFER_UNDERFLOW</tt>
and <tt>BUFFER_OVERFLOW</tt> statuses of
<tt>SSLEngine.unwrap()</tt>. It uses
<tt>SSLSession.getApplicationBufferSize()</tt> and
<tt>SSLSession.getPacketBufferSize()</tt> to determine how large to
make the byte buffers.</p>
<pre class="codeblock">
SSLEngineResult res = engine.unwrap(peerNetData, peerAppData);
switch (res.getStatus()) {

case BUFFER_OVERFLOW:
  // Maybe need to enlarge the peer application data buffer.
  if (engine.getSession().getApplicationBufferSize() &gt;
          peerAppData.capacity()) {
      // enlarge the peer application data buffer
  } else {
        // compact or clear the buffer
  }
  // retry the operation
  break;

case BUFFER_UNDERFLOW:
  // Maybe need to enlarge the peer network packet buffer
  if (engine.getSession().getPacketBufferSize() &gt;
          peerNetData.capacity()) {
      // enlarge the peer network packet buffer
  } else {
        // compact or clear the buffer
  }
  // obtain more inbound network data and then retry the operation
  break;

// Handle other status: CLOSED, OK
...
}

</pre>
<p>The possible handshaking statuses are represented by the
<tt>SSLEngineResult.HandshakeStatus</tt> enum. They represent
whether handshaking has completed, whether the caller needs to
obtain more handshaking data from the peer, send more handshaking
data to the peer, and so on.</p>
<p>Having two statuses per result allows the engine to indicate
that the application must take two actions: one in response to the
handshaking and one representing the overall status of the
<tt>wrap()</tt>/<tt>unwrap()</tt> method. For example, the engine
might, as the result of a single <tt>SSLEngine.unwrap()</tt> call,
return <tt>SSLEngineResult.Status.OK</tt> to indicate that the
input data was processed successfully and
<tt>SSLEngineResult.HandshakeStatus.NEED_UNWRAP</tt> to indicate
that the application should obtain more SSL/TLS encoded data from
the peer and supply it to <tt>SSLEngine.unwrap()</tt> again so that
handshaking can continue. As you can see, the previous examples
were greatly simplified; they would need to be expanded
significantly to properly handle all of these statuses.</p>
<p>Here is an example of how to process handshaking data by
checking handshaking status and the overall status of the
<tt>wrap()</tt>/<tt>unwrap()</tt> method.</p>
<pre class="codeblock">
void doHandshake(SocketChannel socketChannel, SSLEngine engine,
        ByteBuffer myNetData, ByteBuffer peerNetData) throws Exception {

    // Create byte buffers to use for holding application data
    int appBufferSize = engine.getSession().getApplicationBufferSize();
    ByteBuffer myAppData = ByteBuffer.allocate(appBufferSize);
    ByteBuffer peerAppData = ByteBuffer.allocate(appBufferSize);

    // Begin handshake
    engine.beginHandshake();
    SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();

    // Process handshaking message
    while (hs != SSLEngineResult.HandshakeStatus.FINISHED &amp;&amp;
        hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {

        switch (hs) {

        case NEED_UNWRAP:
            // Receive handshaking data from peer
            if (socketChannel.read(peerNetData) &lt; 0) {
                // The channel has reached end-of-stream
            }

            // Process incoming handshaking data
            peerNetData.flip();
            SSLEngineResult res = engine.unwrap(peerNetData, peerAppData);
            peerNetData.compact();
            hs = res.getHandshakeStatus();

            // Check status
            switch (res.getStatus()) {
            case OK :
                // Handle OK status
                break;

            // Handle other status: BUFFER_UNDERFLOW, BUFFER_OVERFLOW, CLOSED
            ...
            }
            break;

        case NEED_WRAP :
            // Empty the local network packet buffer.
            myNetData.clear();

            // Generate handshaking data
            res = engine.wrap(myAppData, myNetData);
            hs = res.getHandshakeStatus();

            // Check status
            switch (res.getStatus()) {
            case OK :
                myNetData.flip();

                // Send the handshaking data to peer
                while (myNetData.hasRemaining()) {
                    socketChannel.write(myNetData);
                }
                break;

            // Handle other status:  BUFFER_OVERFLOW, BUFFER_UNDERFLOW, CLOSED
            ...
            }
            break;

        case NEED_TASK :
            // Handle blocking tasks
            break;

        // Handle other status:  // FINISHED or NOT_HANDSHAKING
        ...
        }
    }

    // Processes after handshaking
    ...
}

</pre>
<h3>Blocking Tasks</h3>
During handshaking, the <tt>SSLEngine</tt> might encounter tasks
that might block or take a long time. For example, a
<tt>TrustManager</tt> may need to connect to a remote certificate
validation service, or a <tt>KeyManager</tt> might need to prompt a
user to determine which certificate to use as part of client
authentication. To preserve the nonblocking nature of
<tt>SSLEngine</tt>, when the engine encounters such a task, it will
return <tt>SSLEngineResult.HandshakeStatus.NEED_TASK</tt>. Upon
receiving this status, the application should invoke
<tt>SSLEngine.getDelegatedTask()</tt> to get the task, and then,
using the threading model appropriate for its requirements, process
the task. The application might, for example, obtain thread(s) from
a thread pool to process the task(s), while the main thread goes
about handling other I/O.
<p>Here is an example that executes each task in a newly created
thread.</p>
<pre class="codeblock">
if (res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_TASK) {
    Runnable task;
    while ((task=engine.getDelegatedTask()) != null) {
        new Thread(task).start();
    }
}
</pre>
The engine will block future <code>wrap/unwrap</code> calls until
all of the outstanding tasks are completed.
<h3>Shutting Down</h3>
For an orderly shutdown of an SSL/TLS connection, the SSL/TLS
protocols require transmission of close messages. Therefore, when
an application is done with the SSL/TLS connection, it should first
obtain the close messages from the <tt>SSLEngine</tt>, then
transmit them to the peer using its transport mechanism, and
finally shut down the transport mechanism. Here is an example.
<pre class="codeblock">
// Indicate that application is done with engine
engine.closeOutbound();

while (!engine.isOutboundDone()) {
    // Get close message
    SSLEngineResult res = engine.wrap(empty, myNetData);

    // Check res statuses

    // Send close message to peer
    while(myNetData.hasRemaining()) {
        int num = socketChannel.write(myNetData);
        if (num == 0) {
            // no bytes written; try again later
        }
        myNetData().compact();
    }
}

// Close transport
socketChannel.close();
</pre>
In addition to an application explicitly closing the
<tt>SSLEngine</tt>, the <tt>SSLEngine</tt> might be closed by the
peer (via receipt of a close message while it is processing
handshake data), or by the <tt>SSLEngine</tt> encountering an error
while processing application or handshake data, indicated by
throwing an <tt>SSLException</tt>. In such cases, the application
should invoke <tt>SSLEngine.wrap()</tt> to get the close message
and send it to the peer until <tt>SSLEngine.isOutboundDone()</tt>
returns true, as shown in the previous example, or the
SSLEngineResult.getStatus() returns CLOSED.
<p>In addition to orderly shutdowns, there can also be unorderly
shutdowns in which the transport link is severed before close
messages are exchanged. In the previous examples, the application
might get <tt>-1</tt> or <tt>IOException</tt> when trying to read from
the nonblocking <tt>SocketChannel</tt>, or get <tt>IOException</tt>
when trying to write to the non-blocking <tt>SocketChannel</tt>.
When you get to the end of your input data, you should call
<tt>engine.closeInbound()</tt>, which will
verify with the SSLEngine that the remote peer has closed cleanly
from the SSL/TLS perspective, and then the application should still
try to shutdown cleanly by using the procedure above. Obviously,
unlike <tt>SSLSocket</tt>, the application using <tt>SSLEngine</tt>
must deal with more state transitions, statuses and programming
than when using <tt>SSLEngine</tt>. Please see the <a href=
"#SSLEngineSample">NIO-based HTTPS server</a> for more information
on writing a <code>SSLEngine</code>-based application.</p>
<a name="SSLSession" id="SSLSession"></a>
<h3><code>SSLSession</code> and <code>ExtendedSSLSession</code>
Interfaces</h3>
<p>A <code>javax.net.ssl.SSLSession</code> represents a security
context negotiated between the two peers of an
<code>SSLSocket</code> or <code>SSLEngine</code> connection. After
a session has been arranged, it can be shared by future
<code>SSLSocket</code> or <code>SSLEngine</code> objects connected
between the same two peers.</p>
<p>In some cases, parameters negotiated during the handshake are
needed later in the handshake to make decisions about trust. For
example, the list of valid signature algorithms might restrict the
certificate types that can be used for authentication. In the Java
SE 7 release, the <code>SSLSession</code> can be retrieved
<i>during</i> the handshake by calling
<code>getHandshakeSession()</code> on an <code>SSLSocket</code> or
<code>SSLEngine</code>. Implementations of
<code>TrustManager</code> or <code>KeyManager</code> can use
<code>getHandshakeSession()</code> to get information about session
parameters to help them make decisions.</p>
<p>A fully initialized <code>SSLSession</code> contains the cipher
suite which will be used for communications over a secure socket as
well as a non-authoritative hint as to the network address of the
remote peer, and management information such as the time of
creation and last use. A session also contains a shared master
secret negotiated between the peers that is used to create
cryptographic keys for encrypting and guaranteeing the integrity of
the communications over an <code>SSLSocket</code> or
<code>SSLEngine</code> connection. The value of this master secret
is known only to the underlying secure socket implementation and is
not exposed through the <code>SSLSession</code> API.</p>
<p>In the Java SE 7 release, a TLS 1.2 session is represented by
<code>ExtendedSSLSession</code>, an implementation of
<code>SSLSession</code>. <code>ExtendedSSLSession</code> adds
methods that describe the signature algorithms that are supported
by the local implementation and the peer.</p>
<p>Calls to <tt>SSLSession.getPacketBufferSize()</tt> and
<tt>SSLSession.getApplicationBufferSize()</tt> also are used to
determine the appropriate buffer sizes used by
<tt>SSLEngine</tt>.</p>
<p><a name="LargePackets" id="LargePackets"></a> <b>Note:</b> The
SSL/TLS protocols specify that implementations are to produce
packets containing at most 16 KB of plaintext. However, some
implementations violate the specification and generate large
records up to 32 KB. If the <tt>SSLEngine.unwrap()</tt> code
detects large inbound packets, the buffer sizes returned by
<tt>SSLSession</tt> will be updated dynamically. Applications
should always <a href="#OperationStatus">check the
<tt>BUFFER_OVERFLOW</tt>/<tt>BUFFER_UNDERFLOW</tt> statuses and
enlarge the corresponding buffers</a> if necessary. SunJSSE will
always send standard compliant 16 KB records and allow incoming 32
KB records. (Also see the System property
<tt>jsse.SSLEngine.acceptLargeFragments</tt> in <a href=
"#Customization">Customization</a> for a workaround.)</p>
<a name="HttpsURLConnection" id="HttpsURLConnection"></a>
<h3><code>HttpsURLConnection</code> Class</h3>
The https protocol is similar to http, but https first establishes
a secure channel via SSL/TLS sockets and then <a href=
"#ciphersuitechoice">verifies the identity of the peer</a> before
requesting/receiving data.
<code>javax.net.ssl.HttpsURLConnection</code> extends the
<code>java.net.HttpsURLConnection</code> class, and adds support
for https-specific features. See the <a href=
"../../../../api/java/net/URL.html"><code>java.net.URL</code></a>,
<a href=
"../../../../api/java/net/URLConnection.html"><code>java.net.URLConnection</code></a>,
<a href=
"../../../../api/java/net/HttpURLConnection.html"><code>java.net.HttpURLConnection</code></a>,
and <a href=
"../../../../api/javax/net/ssl/HttpsURLConnection.html"><code>javax.net.ssl.HttpURLConnection</code></a>
classes for more information about how https URLs are constructed
and used.
<p>Upon obtaining a <code>HttpsURLConnection</code>, you can
configure a number of http/https parameters before actually
initiating the network connection via the method
<code>URLConnection.connect</code>. Of particular interest are:</p>
<ul>
<li><a href="#SettingSSLSocketFactory">Setting the Assigned
<code>SSLSocketFactory</code></a></li>
<li><a href="#SettingHostnameVerifier">Setting the Assigned
<code>HostnameVerifier</code></a></li>
</ul>
<a name="SettingSSLSocketFactory" id="SettingSSLSocketFactory"></a>
<h4>Setting the Assigned <code>SSLSocketFactory</code></h4>
<p>In some situations, it is desirable to specify the
<code>SSLSocketFactory</code> that an
<code>HttpsURLConnection</code> instance uses. For example, you may
wish to tunnel through a proxy type that isn't supported by the
default implementation. The new <code>SSLSocketFactory</code> could
return sockets that have already performed all necessary tunneling,
thus allowing <code>HttpsURLConnection</code> to use additional
proxies.</p>
<p>The <code>HttpsURLConnection</code> class has a default
<code>SSLSocketFactory</code> which is assigned when the class is
loaded. (In particular it is the factory returned by the method
<code>SSLSocketFactory.getDefault</code>.) Future instances of
<code>HttpsURLConnection</code> will inherit the current default
<code>SSLSocketFactory</code> until a new default
<code>SSLSocketFactory</code> is assigned to the class via the
static method
<code>HttpsURLConnection.setDefaultSSLSocketFactory</code>. Once an
instance of <code>HttpsURLConnection</code> has been created, the
inherited <code>SSLSocketFactory</code> on this instance can be
overriden with a call to the <code>setSSLSocketFactory</code>
method.</p>
<p>Note that changing the default static
<code>SSLSocketFactory</code> has no effect on existing instances
of <code>HttpsURLConnections</code>, a call to the
<code>setSSLSocketFactory</code> method is necessary to change the
existing instance.</p>
<p>One can obtain the per-instance or per-class
<code>SSLSocketFactory</code> by making a call to the
<code>getSSLSocketFactory</code>/<code>getDefaultSSLSocketFactory</code>
methods, respectively.</p>
<a name="SettingHostnameVerifier" id="SettingHostnameVerifier"></a>
<h4>Setting the Assigned <code>HostnameVerifier</code></h4>
If the host name of the URL does not match the host name in the
credentials received as part of the SSL/TLS handshake, it is
possible that URL spoofing has occurred. If the implementation
cannot determine a host name match with reasonable certainty, the
SSL implementation will perform a callback to the instance's
assigned <code>HostnameVerifier</code> for further checking. The
host name verifier can perform whatever steps are necessary to make
the determination, such as performing alternate host name pattern
matching or perhaps popping up an interactive dialog box. An
unsuccessful verification by the host name verifier will close the
connection. (See <a href=
"http://www.ietf.org/rfc/rfc2818.txt?number=2818">RFC 2818</a> for
more information regarding host name verification.)
<p>The
<code>setHostnameVerifier</code>/<code>setDefaultHostnameVerifier</code>
methods operate in a similar manner to the
<code>setSSLSocketFactory</code>/<code>setDefaultSSLSocketFactory</code>
methods, in that there are <code>HostnameVerifiers</code> assigned
on a per-instance and per-class basis, and the current values can
be obtained by a call to the
<code>getHostnameVerifier</code>/<code>getDefaultHostnameVerifier</code>
methods.</p>
<a name="SupportClasses" id="SupportClasses"></a>
<h2>Support Classes and Interfaces</h2>
<p>The classes and interfaces in this section are provided to
support the creation and initialization of <code>SSLContext</code>
objects, which are used to create <code>SSLSocketFactory,
SSLServerSocketFactory</code>, and <code>SSLEngine</code> objects.
The support classes and interfaces are part of the
<code>javax.net.ssl</code> package.</p>
<p>Three of the classes described in this section ( <a href=
"#SSLContext"><code>SSLContext</code></a>, <a href=
"#KeyManagerFactory"><code>KeyManagerFactory</code></a>, and
<a href=
"#TrustManagerFactory"><code>TrustManagerFactory</code></a>) are
<i>engine classes</i>. An engine class is an API class for specific
algorithms (or protocols, in the case of <code>SSLContext</code>),
for which implementations may be provided in one or more
Cryptographic Service Provider (provider) packages. For more
information on providers and engine classes, see the "Design
Principles" and "Concepts" sections of the <a href=
"../crypto/CryptoSpec.html">Java Cryptography Architecture
Reference Guide</a>.</p>
<p>The <code>SunJSSE</code> provider that comes standard with JSSE
provides <code>SSLContext</code>, <code>KeyManagerFactory</code>,
and <code>TrustManagerFactory</code> implementations, as well as
implementations for engine classes in the standard Java security
(<code>java.security</code>) API. The implementations supplied by
<code>SunJSSE</code> are:</p>
<table border="1" summary="SunJSSE implementations">
<tr>
<th id="class">Engine Class<br />
Implemented</th>
<th id="algorithm">Algorithm or<br />
Protocol</th>
</tr>
<tr>
<td headers="class"><code>KeyStore</code></td>
<td headers="algorithm"><code>PKCS12</code></td>
</tr>
<tr>
<td headers="class"><code>KeyManagerFactory</code></td>
<td headers="algorithm"><code>PKIX</code>,
<code>SunX509</code></td>
</tr>
<tr>
<td headers="class"><code>TrustManagerFactory</code></td>
<td headers="algorithm"><code>PKIX</code> (a.k.a. <code>X509</code>
or <code>SunPKIX</code>), <code>SunX509</code></td>
</tr>
<tr>
<td headers="class"><code>SSLContext</code></td>
<td headers="algorithm"><code>SSLv3</code> (a.k.a.
<code>SSL</code>), <code>TLSv1</code> (a.k.a. <code>TLS</code>),
<code>TLSv1.1</code>, <code>TLSv1.2</code></td>
</tr>
</table>
<a name="SSLContext" id="SSLContext"></a>
<h3><code>SSLContext</code> Class</h3>
<p><code>javax.net.ssl.SSLContext</code> is an engine class for an
implementation of a secure socket protocol. An instance of this
class acts as a factory for SSL socket factories and SSL engines.
An <code>SSLContext</code> holds all of the state information
shared across all objects created under that context. For example,
session state is associated with the <code>SSLContext</code> when
it is negotiated through the handshake protocol by sockets created
by socket factories provided by the context. These cached sessions
can be reused and shared by other sockets created under the same
context.</p>
<p>Each instance is configured through its <code>init</code> method
with the keys, certificate chains, and trusted root CA certificates
that it needs to perform authentication. This configuration is
provided in the form of key and trust managers. These managers
provide support for the authentication and key agreement aspects of
the cipher suites supported by the context.</p>
<p>Currently, only X.509-based managers are supported.</p>
<h4>Creating an <code>SSLContext</code> Object</h4>
Like other JCA provider-based "engine" classes,
<code>SSLContext</code> objects are created using the
<code>getInstance</code> factory methods of the
<code>SSLContext</code> class. These static methods each return an
instance that implements <i>at least</i> the requested secure
socket protocol. The returned instance may implement other
protocols too. For example, <code>getInstance("TLSv1")</code> may
return a instance which implements <code>"TLSv1"</code>,
<code>"TLSv1.1"</code> and <code>"TLSv1.2"</code>. The
<code>getSupportedProtocols</code> method returns a list of
supported protocols when an <code>SSLSocket, SSLServerSocket</code>
or <code>SSLEngine</code> is created from this context. You can
control which protocols are actually enabled for an SSL connection
by using the method <code>setEnabledProtocols(String[]
protocols)</code>.
<p><b>Note:</b> An <code>SSLContext</code> object is automatically
created, initialized, and statically assigned to the
<code>SSLSocketFactory</code> class when you call
<code>SSLSocketFactory.getDefault</code>. Therefore, you don't have
to directly create and initialize an <code>SSLContext</code> object
(unless you want to override the default behavior).</p>
<p>To create an <code>SSLContext</code> object by calling a
<code>getInstance</code> factory method, you must specify the
protocol name. You may also specify which provider you want to
supply the implementation of the requested protocol:</p>
<pre class="codeblock">
public static SSLContext getInstance(String protocol);

public static SSLContext getInstance(String protocol,
                                     String provider);

public static SSLContext getInstance(String protocol,
                                     Provider provider);
</pre>
<p>If just a protocol name is specified, the system will determine
if there is an implementation of the requested protocol available
in the environment, and if there is more than one, if there is a
preferred one.</p>
<p>If both a protocol name and a provider are specified, the system
will determine if there is an implementation of the requested
protocol in the provider requested, and throw an exception if there
is not.</p>
<p>A protocol is a string (such as "SSL") that describes the secure
socket protocol desired. Common protocol names for
<code>SSLContext</code> objects are defined in <a href=
"#AppA">Appendix A</a>.</p>
<p>Here is an example of obtaining an <code>SSLContext</code>:</p>
<pre class="codeblock">
SSLContext sc = SSLContext.getInstance("SSL");
</pre>
<p>A newly-created <code>SSLContext</code> should be initialized by
calling the <code>init</code> method:</p>
<pre class="codeblock">
public void init(KeyManager[] km, TrustManager[] tm,
                   SecureRandom random);
</pre>
<p>If the <code>KeyManager[]</code> parameter is null, then an
empty <code>KeyManager</code> will be defined for this context. If
the <code>TrustManager[]</code> parameter is null, the installed
security providers will be searched for the highest-priority
implementation of the <a href=
"#TrustManagerFactory"><code>TrustManagerFactory</code></a>, from
which an appropriate <code>TrustManager</code> will be obtained.
Likewise, the SecureRandom parameter may be null, in which case a
default implementation will be used.</p>
<p>If the internal default context is used, (e.g. a
<code>SSLContext</code> is created by
<code>SSLSocketFactory.getDefault()</code> or
<code>SSLServerSocketFactory.getDefault()</code>), <a href=
"#CustomizingStores">a default <code>KeyManager</code> and a
<code>TrustManager</code></a> are created. The default
<code>SecureRandom</code> implementation is also chosen.</p>
<a name="TrustManager" id="TrustManager"></a>
<h3><code>TrustManager</code> Interface</h3>
The primary responsibility of the <code>TrustManager</code> is to
determine whether the presented authentication credentials should
be trusted. If the credentials are not trusted, the connection will
be terminated. To authenticate the remote identity of a secure
socket peer, you need to initialize an <code>SSLContext</code>
object with one or more <code>TrustManager</code>s. You need to
pass one <code>TrustManager</code> for each authentication
mechanism that is supported. If null is passed into the
<code>SSLContext</code> initialization, a trust manager will be
created for you. Typically, there is a single trust manager that
supports authentication based on X.509 public key certificates
(e.g. <code>X509TrustManager</code>). Some secure socket
implementations may also support authentication based on shared
secret keys, Kerberos, or other mechanisms.
<p><code>TrustManager</code>s are created either by a
<code>TrustManagerFactory</code>, or by providing a concrete
implementation of the interface.</p>
<a name="TrustManagerFactory" id="TrustManagerFactory"></a>
<h3><code>TrustManagerFactory</code> Class</h3>
<p>The <code>javax.net.ssl.TrustManagerFactory</code> is an engine
class for a provider-based service that acts as a factory for one
or more types of <code>TrustManager</code> objects. Because it is
provider-based, additional factories can be implemented and
configured that provide additional or alternate trust managers that
provide more sophisticated services or that implement
installation-specific authentication policies.</p>
<h4>Creating a <code>TrustManagerFactory</code></h4>
You create an instance of this class in a similar manner to
<code>SSLContext</code>, except for passing an algorithm name
string instead of a protocol name to the <code>getInstance</code>
method:
<pre class="codeblock">
public static TrustManagerFactory
                  getInstance(String algorithm);

public static TrustManagerFactory
                  getInstance(String algorithm,
                              String provider);

public static TrustManagerFactory
                  getInstance(String algorithm,
                              Provider provider);
</pre>
<p>A sample algorithm name string is:</p>
<i>"PKIX"</i>
<p>A sample call is the following:</p>
<pre class="codeblock">
TrustManagerFactory tmf =
    TrustManagerFactory.getInstance("PKIX", "SunJSSE");
</pre>
<p>The above call will create an instance of the
<code>SunJSSE</code> provider's PKIX trust manager factory. This
factory can then be used to create trust managers which provide
X.509 PKIX-based certification path validity checking.</p>
<p>When initializing a <code>SSLContext</code>, you can use trust
managers created from a trust manager factory, or you can write
your own trust manager, perhaps using the <a href=
"../../../../api/java/security/cert/CertPath.html"><code>CertPath</code></a>
API. (See the <a href="../certpath/CertPathProgGuide.html">Java
Certification Path API Programmer's Guide</a> for details.) You
don't need to use a trust manager factory at all if you implement a
trust manager using the <a href=
"../../../../api/javax/net/ssl/X509TrustManager.html"><code>X509TrustManager</code></a>
interface.</p>
<p>A newly-created factory should be initialized by calling one of
the <code>init</code> methods:</p>
<pre class="codeblock">
public void init(KeyStore ks);
public void init(ManagerFactoryParameters spec);
</pre>
<p>You should call whichever <code>init</code> method is
appropriate for the <code>TrustManagerFactory</code> you are using.
(Ask the provider vendor.)</p>
<p>For many factories, such as the "SunX509"
<code>TrustManagerFactory</code> from the <code>SunJSSE</code>
provider, the <code>KeyStore</code> is the only information
required in order to initialize the
<code>TrustManagerFactory</code> and thus the first
<code>init</code> method is the appropriate one to call. The
<code>TrustManagerFactory</code> will query the
<code>KeyStore</code> for information on which remote certificates
should be trusted during authorization checks.</p>
<p>In some cases, initialization parameters other than a
<code>KeyStore</code> may be needed by a provider. Users of that
particular provider are expected to pass an implementation of the
appropriate <code>ManagerFactoryParameters</code> as defined by the
provider. The provider can then call the specified methods in the
<code>ManagerFactoryParameters</code> implementation to obtain the
needed information.</p>
<p>For example, suppose the <code>TrustManagerFactory</code>
provider requires initialization parameters B, R, and S from any
application that wishes to use that provider. Like all providers
that require initialization parameters other than a KeyStore, the
provider will require that the application provide an instance of a
class that implements a particular
<code>ManagerFactoryParameters</code> sub-interface. In our
example, suppose the provider requires that the calling application
implement and create an instance of
<code>MyTrustManagerFactoryParams</code> and pass it to the second
<code>init</code>. Here is what
<code>MyTrustManagerFactoryParams</code> may look like:</p>
<pre class="codeblock">
public interface MyTrustManagerFactoryParams extends 
       ManagerFactoryParameters {
    public boolean getBValue();
    public float getRValue();
    public String getSValue():
}
</pre>
<p>Some trustmanagers are capable of making trust decisions without
having to be explicitly initialized with a KeyStore object or any
other parameters. For example, they may access trust material from
a local directory service via LDAP, may use a remote online
certificate status checking server, or may access default trust
material from a standard local location.</p>
<a name="CERTPATH" id="CERTPATH"></a>
<h4>PKIX TrustManager Support</h4>
<p>The default trust manager algorithm is "PKIX". The default can
be changed by editing the
<code>ssl.TrustManagerFactory.algorithm</code> property in the
<code>java.security</code> file.</p>
<p>The PKIX trust manager factory uses the <a href=
"../certpath/CertPathProgGuide.html">CertPath PKIX</a>
implementation from an installed security provider; a "SUN"
CertPath provider is supplied with the Java SE Development Kit 6.
The trust manager factory can be initialized using the normal
<code>init(KeyStore ks)</code> method, or by passing CertPath
parameters to the the PKIX trust manager using the newly introduced
class <a href=
"../../../../api/javax/net/ssl/CertPathTrustManagerParameters.html">
<tt>javax.net.ssl.CertPathTrustManagerParameters</tt></a>.</p>
<p>Here is an example of how to get the trust manager to use a
particular LDAP certificate store and enable revocation
checking.</p>
<pre class="codeblock">
import javax.net.ssl.*;
import java.security.cert.*;
import java.security.KeyStore;
...

// Create PKIX parameters
KeyStore anchors = KeyStore.getInstance("JKS");
anchors.load(new FileInputStream(anchorsFile));
CertPathParameters pkixParams = new PKIXBuilderParameters(anchors,
    new X509CertSelector());

// Specify LDAP certificate store to use
LDAPCertStoreParameters lcsp = new LDAPCertStoreParameters("ldap.imc.org", 389);
pkixParams.addCertStore(CertStore.getInstance("LDAP", lcsp));

// Specify that revocation checking is to be enabled
pkixParams.setRevocationEnabled(true);

// Wrap them as trust manager parameters
ManagerFactoryParameters trustParams =
    new CertPathTrustManagerParameters(pkixParams);

// Create TrustManagerFactory for PKIX-compliant trust managers
TrustManagerFactory factory = TrustManagerFactory.getInstance("PKIX");

// Pass parameters to factory to be passed to CertPath implementation
factory.init(trustParams);

// Use factory
SSLContext ctx = SSLContext.getInstance("TLS");
ctx.init(null, factory.getTrustManagers(), null);
</pre>
<p>If the <code>init(KeyStore ks)</code> method is used, default
PKIXParameters are used with the exception that revocation checking
is disabled. It can be enabled by setting the system property
<code>com.sun.net.ssl.checkRevocation</code> to <code>true</code>.
Note that this setting requires that the CertPath implementation
can locate revocation information by itself. The PKIX
implementation in the SUN provider can do this in many cases but
requires that the system property
<code>com.sun.security.enableCRLDP</code> be set to
<code>true</code>.</p>
<p>More information about PKIX and the CertPath API can be found in
the <a href="../certpath/CertPathProgGuide.html">Java Certificate
Path API Programming Guide</a>.</p>
<a name="X509TrustManager" id="X509TrustManager"></a>
<h3><code>X509TrustManager</code> Interface</h3>
<p>The <code>javax.net.ssl.X509TrustManager</code> interface
extends the general <code>TrustManager</code> interface. This
interface must be implemented by a trust manager when using
X.509-based authentication.</p>
<p>In order to support X.509 authentication of remote socket peers
through JSSE, an instance of this interface must be passed to the
<code>init</code> method of an <code>SSLContext</code> object.</p>
<h4>Creating an <code>X509TrustManager</code></h4>
You can either implement this interface directly yourself or obtain
one from a provider-based <code>TrustManagerFactory</code> (such as
that supplied by the <code>SunJSSE</code> provider). You could also
implement your own that delegates to a factory-generated trust
manager. For example, you might do this in order to filter the
resulting trust decisions and query an end-user through a graphical
user interface.
<p><b>Note:</b> If a null KeyStore parameter is passed to the
<code>SunJSSE</code> "PKIX" or "SunX509"
<code>TrustManagerFactory</code>, the factory uses the following
steps to try to find trust material:</p>
<ol>
<li>If the <a href="#SystemProps">system property</a>:
<pre class="codeblock">
javax.net.ssl.trustStore
</pre>
is defined, then the <code>TrustManagerFactory</code> attempts to
find a file using the filename specified by that system property,
and uses that file for the KeyStore. If the
<code>javax.net.ssl.trustStorePassword</code> system property is
also defined, its value is used to check the integrity of the data
in the truststore before opening it.
<p>If <code>javax.net.ssl.trustStore</code> is defined but the
specified file does not exist, then a default
<code>TrustManager</code> using an empty keystore is created.</p>
</li>
<li>If the <code>javax.net.ssl.trustStore</code> system property
was not specified, then if the file
<pre class="codeblock">
&lt;java-home&gt;/lib/security/jssecacerts
</pre>
exists, that file is used. (See <a href="#javaHome">The
Installation Directory &lt;java-home&gt;</a> for information about
what <code>&lt;java-home&gt;</code> refers to.) Otherwise,</li>
<li>If the file
<pre class="codeblock">
&lt;java-home&gt;/lib/security/cacerts
</pre>
exists, that file is used.</li>
</ol>
<p>(If none of these files exists, that may be okay because there
are SSL cipher suites which are anonymous, that is, which don't do
any authentication and thus don't need a truststore.)</p>
<p>The factory looks for a file specified via the security property
<code>javax.net.ssl.trustStore</code> or for the
<code>jssecacerts</code> file before checking for a
<code>cacerts</code> file so that you can provide a JSSE-specific
set of trusted root certificates separate from ones that might be
present in <code>cacerts</code> for code-signing purposes.</p>
<a name="OwnX509TM" id="OwnX509TM"></a>
<h4>Creating Your Own <code>X509TrustManager</code></h4>
If the supplied <code>X509TrustManager</code> behavior isn't
suitable for your situation, you can create your own
<code>X509TrustManager</code> by either creating and registering
your own <code>TrustManagerFactory</code> or by implementing the
<code>X509TrustManager</code> interface directly.
<p>The following <code>MyX509TrustManager</code> class enhances the
default <code>SunJSSE</code> <code>X509</code>
<code>TrustManager</code> behavior by providing alternative
authentication logic when the default <code>SunJSSE</code>
<code>X509</code> <code>TrustManager</code> fails.</p>
<pre class="codeblock">
class MyX509TrustManager implements X509TrustManager {

     /*
      * The default PKIX X509TrustManager9.  We'll delegate
      * decisions to it, and fall back to the logic in this class if the
      * default X509TrustManager doesn't trust it.
      */
     X509TrustManager pkixTrustManager;

     MyX509TrustManager() throws Exception {
         // create a "default" JSSE X509TrustManager.

         KeyStore ks = KeyStore.getInstance("JKS");
         ks.load(new FileInputStream("trustedCerts"),
             "passphrase".toCharArray());

         TrustManagerFactory tmf =
                TrustManagerFactory.getInstance("PKIX");
         tmf.init(ks);

         TrustManager tms [] = tmf.getTrustManagers();

         /*
          * Iterate over the returned trustmanagers, look
          * for an instance of X509TrustManager.  If found,
          * use that as our "default" trust manager.
          */
         for (int i = 0; i &lt; tms.length; i++) {
             if (tms[i] instanceof X509TrustManager) {
                 pkixTrustManager = (X509TrustManager) tms[i];
                 return;
             }
         }

         /*
          * Find some other way to initialize, or else we have to fail the
          * constructor.
          */
         throw new Exception("Couldn't initialize");
     }

     /*
      * Delegate to the default trust manager.
      */
     public void checkClientTrusted(X509Certificate[] chain, String authType)
                 throws CertificateException {
         try {
             pkixTrustManager.checkClientTrusted(chain, authType);
         } catch (CertificateException excep) {
             // do any special handling here, or rethrow exception.
         }
     }

     /*
      * Delegate to the default trust manager.
      */
     public void checkServerTrusted(X509Certificate[] chain, String authType)
                 throws CertificateException {
         try {
             pkixTrustManager.checkServerTrusted(chain, authType);
         } catch (CertificateException excep) {
             /*
              * Possibly pop up a dialog box asking whether to trust the
              * cert chain.
              */
         }
     }

     /*
      * Merely pass this through.
      */
     public X509Certificate[] getAcceptedIssuers() {
         return pkixTrustManager.getAcceptedIssuers();
     }
}

</pre>
<p>Once you have created such a trust manager, assign it to an
<code>SSLContext</code> via the <code>init</code> method. Future
<code>SocketFactories</code> created from this
<code>SSLContext</code> will use your new <code>TrustManager</code>
when making trust decisions.</p>
<pre class="codeblock">
TrustManager[] myTMs = new TrustManager [] {
                          new MyX509TrustManager() };
SSLContext ctx = SSLContext.getInstance("TLS");
ctx.init(null, myTMs, null);
</pre>
<h4>Updating the <code>keyStore</code> Dynamically</h4>
<p>You can enhance <code>MyX509TrustManager</code> to handle
dynamic keystore updates. When a <code>checkClientTrusted</code> or
<code>checkServerTrusted</code> test fails and does not establish a
trusted certificate chain, you can add the required trusted
certificate to the keystore. You need to create a new
<code>pkixTrustManager</code> from the
<code>TrustManagerFactory</code> initialized with the updated
keystore. When you establish a new connection (using the previously
initialized <code>SSLContext</code>), the newly added certificate
will be used when making trust decisions.</p>
<a name="X509ExtendedTrustManager" id=
"X509ExtendedTrustManager"></a>
<h3><code>X509ExtendedTrustManager Class</code></h3>
<p>In the Java SE 7 release, the
<code>X509ExtendedTrustManager</code> class is an abstract
implementation of the <code>X509TrustManager</code> interface. It
adds methods for connection-sensitive trust management. In
addition, it enables endpoint verification at the TLS layer.</p>
<p>In TLS 1.2 and later, both client and server are able to specify
which hash and signature algorithms they will accept. In order to
authenticate the remote side, authentication decisions must be
based on both X509 certificates and the local accepted hash and
signature algorithms. The local accepted hash and signature
algorithms can be got from the
<code>ExtendedSSLSession.getLocalSupportedSignatureAlgorithms()</code>
method.</p>
<p>The <code>ExtendedSSLSession</code> object can be retrieved by
calling the <code>SSLSocket.getHandshakeSession()</code> method or
the <code>SSLEngine.getHandshakeSession()</code> method.</p>
<p>The <code>X509TrustManager</code> interface is not
connection-sensitive. It provides no way to access
<code>SSLSocket</code> or <code>SSLEngine</code> session
properties.</p>
<p>Besides TLS 1.2 support, the
<code>X509ExtendedTrustManager</code> class also support algorithm
constraints and SSL layer hostname verification. For JSSE providers
and trust manager implementations, the
<code>X509ExtendedTrustManager</code> class is highly recommended
rather than the legacy <code>X509TrustManager</code> interface.</p>
<h4>Creating an <code>X509ExtendedTrustManager</code></h4>
<p>You can either create an <code>X509ExtendedTrustManager</code>
sublcass yourself (which is outlined in the following section) or
obtain one from a provider-based <code>TrustManagerFactory</code>
(such as that supplied by the <code>SunJSSE</code> provider). In
the Java SE 7 release, the PKIX or SunX509
<code>TrustManagerFactory</code> returns an
<code>X509ExtendedTrustManager</code> instance.</p>
<a name="OwnX509ETM" id="OwnX509ETM"></a>
<h4>Creating Your Own <code>X509ExtendedTrustManager</code></h4>
<p>This section outlines how to subclass
<code>X509ExtendedTrustManager</code> in nearly the same way as
described for <code>X509TrustManager</code>.</p>
<p>The following class uses the "PKIX"
<code>TrustManagerFactory</code> to locate a default
<code>X509ExtendedTrustManager</code> that will be used to make
decisions about trust. If the default trust manager fails for any
reason, the subclass is able to add other behavior. In the example,
these locations are indicated by comments in the <code>catch</code>
clauses.</p>
<pre class="codeblock">
import java.io.*;
import java.net.*;

import java.security.*;
import java.security.cert.*;
import javax.net.ssl.*;

public class MyX509ExtendedTrustManager extends X509ExtendedTrustManager {

     /*
      * The default PKIX X509ExtendedTrustManager.  We'll delegate
      * decisions to it, and fall back to the logic in this class if the
      * default X509ExtendedTrustManager doesn't trust it.
      */
     X509ExtendedTrustManager pkixTrustManager;

     MyX509ExtendedTrustManager() throws Exception {
         // create a &quot;default&quot; JSSE X509ExtendedTrustManager.

         KeyStore ks = KeyStore.getInstance(&quot;JKS&quot;);
         ks.load(new FileInputStream(&quot;trustedCerts&quot;),
             &quot;passphrase&quot;.toCharArray());

         TrustManagerFactory tmf =
                TrustManagerFactory.getInstance(&quot;PKIX&quot;);
         tmf.init(ks);

         TrustManager tms [] = tmf.getTrustManagers();

         /*
          * Iterate over the returned trustmanagers, look
          * for an instance of X509TrustManager.  If found,
          * use that as our &quot;default&quot; trust manager.
          */
         for (int i = 0; i &lt; tms.length; i++) {
             if (tms[i] instanceof X509ExtendedTrustManager) {
                 pkixTrustManager = (X509ExtendedTrustManager) tms[i];
                 return;
             }
         }

         /*
          * Find some other way to initialize, or else we have to fail the
          * constructor.
          */
         throw new Exception(&quot;Couldn't initialize&quot;);
     }

     /*
      * Delegate to the default trust manager.
      */
     public void checkClientTrusted(X509Certificate[] chain, String authType)
                 throws CertificateException {
         try {
             pkixTrustManager.checkClientTrusted(chain, authType);
         } catch (CertificateException excep) {
             // do any special handling here, or rethrow exception.
         }
     }

     /*
      * Delegate to the default trust manager.
      */
     public void checkServerTrusted(X509Certificate[] chain, String authType)
                 throws CertificateException {
         try {
             pkixTrustManager.checkServerTrusted(chain, authType);
         } catch (CertificateException excep) {
             /*
              * Possibly pop up a dialog box asking whether to trust the
              * cert chain.
              */
         }
     }

     /*
      * Connection-sensitive verification.
      */
     public void checkClientTrusted(X509Certificate[] chain, String authType,
                  Socket socket)
                 throws CertificateException {
       try {
           pkixTrustManager.checkClientTrusted(chain, authType, socket);
       } catch (CertificateException excep) {
           // do any special handling here, or rethrow exception.
       }
     }

     public void checkClientTrusted(X509Certificate[] chain, String authType,
                  SSLEngine engine)
                 throws CertificateException {
       try {
           pkixTrustManager.checkClientTrusted(chain, authType, engine);
       } catch (CertificateException excep) {
           // do any special handling here, or rethrow exception.
       }
     }

     public void checkServerTrusted(X509Certificate[] chain, String authType,
                  Socket socket)
                 throws CertificateException {
       try {
           pkixTrustManager.checkServerTrusted(chain, authType, socket);
       } catch (CertificateException excep) {
           // do any special handling here, or rethrow exception.
       }
     }

     public void checkServerTrusted(X509Certificate[] chain, String authType,
                  SSLEngine engine)
                 throws CertificateException {
       try {
           pkixTrustManager.checkServerTrusted(chain, authType, engine);
       } catch (CertificateException excep) {
           // do any special handling here, or rethrow exception.
       }
     }
     
     /*
      * Merely pass this through.
      */
     public X509Certificate[] getAcceptedIssuers() {
         return pkixTrustManager.getAcceptedIssuers();
     }
}
</pre>
<a name="KeyManager" id="KeyManager"></a>
<h3><code>KeyManager</code> Interface</h3>
<p>The primary responsibility of the <code>KeyManager</code> is to
select the authentication credentials that will eventually be sent
to the remote host. To authenticate yourself (a local secure socket
peer) to a remote peer, you need to initialize an
<code>SSLContext</code> object with one or more
<code>KeyManager</code>s. You need to pass one
<code>KeyManager</code> for each different authentication mechanism
that will be supported. If null is passed into the
<code>SSLContext</code> initialization, an empty
<code>KeyManager</code> will be created. If the internal default
context is used (e.g. a <code>SSLContext</code> created by
<code>SSLSocketFactory.getDefault()</code> or
<code>SSLServerSocketFactory.getDefault()</code>), a <a href=
"#CustomizingStores">default <code>KeyManager</code></a> is
created. Typically, there is a single key manager that supports
authentication based on <code>X.509</code> public key certificates.
Some secure socket implementations may also support authentication
based on shared secret keys, Kerberos, or other mechanisms.</p>
<p><code>KeyManager</code>s are created either by a
<code>KeyManagerFactory</code>, or by providing a concrete
implementation of the interface.</p>
<a name="KeyManagerFactory" id="KeyManagerFactory"></a>
<h3><code>KeyManagerFactory</code> Class</h3>
<p><code>javax.net.ssl.KeyManagerFactory</code> is an engine class
for a provider-based service that acts as a factory for one or more
types of <code>KeyManager</code> objects. The <code>SunJSSE</code>
provider implements a factory which can return a basic X.509 key
manager. Because it is provider-based, additional factories can be
implemented and configured to provide additional or alternate key
managers.</p>
<h4>Creating a <code>KeyManagerFactory</code></h4>
You create an instance of this class in a similar manner to
<code>SSLContext</code>, except for passing an algorithm name
string instead of a protocol name to the <code>getInstance</code>
method:
<pre class="codeblock">
public static KeyManagerFactory
                  getInstance(String algorithm);

public static KeyManagerFactory
                  getInstance(String algorithm,
                              String provider);

public static KeyManagerFactory
                  getInstance(String algorithm,
                              Provider provider);
</pre>
<p>A sample algorithm name string is:</p>
<i>"SunX509"</i>
<p>A sample call is the following:</p>
<pre class="codeblock">
KeyManagerFactory kmf =
    KeyManagerFactory.getInstance("SunX509", "SunJSSE");
</pre>
<p>The above call will create an instance of the
<code>SunJSSE</code> provider's default key manager factory, which
provides basic X.509-based authentication keys.</p>
<p>A newly-created factory should be initialized by calling one of
the <code>init</code> methods:</p>
<pre class="codeblock">
public void init(KeyStore ks, char[] password);
public void init(ManagerFactoryParameters spec);
</pre>
<p>You should call whichever <code>init</code> method is
appropriate for the KeyManagerFactory you are using. (Ask the
provider vendor.)</p>
<p>For many factories, such as the default "SunX509"
<code>KeyManagerFactory</code> from the <code>SunJSSE</code>
provider, the <code>KeyStore</code> and password are the only
information required in order to initialize the
<code>KeyManagerFactory</code> and thus the first <code>init</code>
method is the appropriate one to call. The
<code>KeyManagerFactory</code> will query the <code>KeyStore</code>
for information on which private key and matching public key
certificates should be used for authenticating to a remote socket
peer. The password parameter specifies the password that will be
used with the methods for accessing keys from the
<code>KeyStore</code>. All keys in the <code>KeyStore</code> must
be protected by the same password.</p>
<p>In some cases, initialization parameters other than a
<code>KeyStore</code> and password may be needed by a provider.
Users of that particular provider are expected to pass an
implementation of the appropriate
<code>ManagerFactoryParameters</code> as defined by the provider.
The provider can then call the specified methods in the
<code>ManagerFactoryParameters</code> implementation to obtain the
needed information.</p>
<p>Some factories are capable of providing access to authentication
material without having to be initialized with a KeyStore object or
any other parameters. For example, they may access key material as
part of a login mechanism such as one based on JAAS, the Java
Authentication and Authorization Service.</p>
<p>As indicated above, the <code>SunJSSE</code> provider supports a
"SunX509" factory that must be initialized with a KeyStore
parameter.</p>
<a name="X509KeyManager" id="X509KeyManager"></a>
<h3><code>X509KeyManager</code> Interface</h3>
<p>The <code>javax.net.ssl.X509KeyManager</code> interface extends
the general <code>KeyManager</code> interface. It must be
implemented by a key manager for X.509-based authentication. In
order to support X.509 authentication to remote socket peers
through JSSE, an instance of this interface must be passed to the
<code>init</code> method of an <code>SSLContext</code> object.</p>
<h4>Creating an <code>X509KeyManager</code></h4>
You can either implement this interface directly yourself or obtain
one from a provider-based <code>KeyManagerFactory</code> (such as
those supplied by the <code>SunJSSE</code> provider). You could
also implement your own that delegates to a factory-generated key
manager. For example, you might do this in order to filter the
resulting keys and query an end-user through a graphical user
interface.
<h4>Creating Your Own <code>X509KeyManager</code></h4>
<p>If the default <code>X509KeyManager</code> behavior isn't
suitable for your situation, you can create your own
<code>X509KeyManager</code> in a way similar to that shown in
<a href="#OwnX509TM">Creating Your Own
<code>X509TrustManager</code></a>.</p>
<a name="X509ExtendedKeyManager" id="X509ExtendedKeyManager"></a>
<h3><code>X509ExtendedKeyManager</code> Class</h3>
<p>The <code>X509ExtendedKeyManager</code> abstract class is an
implementation of the <code>X509KeyManager</code> interface which
allows for connection-specific key selection. It adds two methods
that select a key alias for client or server based on the key type,
allowed issuers, and current <code>SSLEngine</code>.</p>
<pre class="codeblock">
public String chooseEngineClientAlias(String[] keyType,
                                      Principal[] issuers,
                                      SSLEngine engine)

public String chooseEngineServerAlias(String keyType,
                                      Principal[] issuers,
                                      SSLEngine engine)
</pre>
<p>If a key manager is not a instance of the
<code>X509ExtendedKeyManager</code> class, it will not work with
the <code>SSLEngine</code> class.</p>
<p>For JSSE providers and key manager implementations, the
<code>X509ExtendedKeyManager</code> class is highly recommended
rather than the legacy <code>X509KeyManager</code> interface.</p>
<p>In TLS 1.2 and later, both client and server are able to specify
which hash and signature algorithms they will accept. In order to
pass the authentication required by the remote side, local key
selection decisions must be based on both X509 certificate and the
remote accepted hash and signature algorithms. The remote accepted
hash and signature algorithms can be retrieved from the method
<code>ExtendedSSLSession.getPeerSupportedSignatureAlgorithms()</code>.</p>
<p>You can create your own <code>X509ExtendedKeyManager</code>
subclass in a way similar to that shown in <a href=
"#OwnX509ETM">Creating Your Own
<code>X509ExtendedTrustManager</code></a>.</p>
<a name="RelsTM_KM" id="RelsTM_KM"></a>
<h3>Relationships Between <code>TrustManager</code>s and
<code>KeyManager</code>s</h3>
Historically, there has been confusion regarding the jobs of
<code>TrustManager</code>s and <code>KeyManager</code>s. In
summary, here are the primary responsibilities of each manager
type:
<table summary="manager types and functions" width="400" border="1"
cellspacing="2" cellpadding="0">
<thead>
<tr>
<th width="30%"><b>Type</b></th>
<th width="70%"><b>Function</b></th>
</tr>
</thead>
<tbody>
<tr>
<td width="30%"><code>TrustManager</code></td>
<td width="70%">Determines whether the remote authentication
credentials (and thus the connection) should be trusted.</td>
</tr>
<tr>
<td width="30%"><code>KeyManager</code></td>
<td width="70%">Determines which authentication credentials to send
to the remote host.</td>
</tr>
</tbody>
</table>
<a name="SecondarySupportClasses" id="SecondarySupportClasses"></a>
<h2>Secondary Support Classes and Interfaces</h2>
<p>These classes are provided as part of the JSSE API to support
the creation, use, and management of secure sockets. They are less
likely to be used by secure socket applications than are the core
and support classes. The secondary support classes and interfaces
are part of the <code>javax.net.ssl</code> and
<code>javax.security.cert</code> packages.</p>
<a name="SSLParameters" id="SSLParameters"></a>
<h3><code>SSLParameters</code> Class</h3>
<p><code>SSLParameters</code> encapsulates things that affect a TLS
connection:</p>
<ul>
<li>The list of ciphersuites to be accepted in an SSL/TLS
handshake</li>
<li>The list of protocols to be allowed</li>
<li>The endpoint identification algorithm during SSL/TLS
handshaking</li>
<li>The algorithm constraints</li>
<li>Whether SSL/TLS servers should request or require client
authentication</li>
</ul>
<p>You can retrieve the current <code>SSLParameters</code> for an
<code>SSLSocket</code> or <code>SSLEngine</code> using the
following methods:</p>
<ul>
<li><code>getSSLParameters()</code> in <code>SSLSocket</code>,
<code>SSLServerSocket</code> and <code>SSLEngine</code></li>
<li><code>getDefaultSSLParameters()</code> and
<code>getSupportedSSLParamters()</code> in
<code>SSLContext</code></li>
</ul>
<p>Assign <code>SSLParameters</code> with the
<code>setSSLParameters()</code> method in <code>SSLSocket</code>,
<code>SSLServerSocket</code>, or <code>SSLEngine</code>.</p>
<a name="SSLSessionContext" id="SSLSessionContext"></a>
<h3><code>SSLSessionContext</code> Interface</h3>
<p>A <code>javax.net.ssl.SSLSessionContext</code> is a grouping of
<a href="#SSLSession"><code>SSLSession</code></a>s associated with
a single entity. For example, it could be associated with a server
or client that participates in many sessions concurrently. The
methods on this interface enable the enumeration of all sessions in
a context and allow lookup of specific sessions via their session
IDs.</p>
<p>An <code>SSLSessionContext</code> may optionally be obtained
from an <code>SSLSession</code> by calling the SSLSession
<code>getSessionContext</code> method. The context may be
unavailable in some environments, in which case the
<code>getSessionContext</code> method returns null.</p>
<a name="SSLSessionBindingListener" id=
"SSLSessionBindingListener"></a>
<h3><code>SSLSessionBindingListener</code> Interface</h3>
<p><code>javax.net.ssl.SSLSessionBindingListener</code> is an
interface implemented by objects which want to be notified when
they are being bound or unbound from an <a href=
"#SSLSession"><code>SSLSession</code></a>.</p>
<a name="SSLSessionBindingEvent" id="SSLSessionBindingEvent"></a>
<h3><code>SSLSessionBindingEvent</code> Class</h3>
<p>A <code>javax.net.ssl.SSLSessionBindingEvent</code> is the event
communicated to an <a href=
"#SSLSessionBindingListener"><code>SSLSessionBindingListener</code></a>
when it is bound or unbound from an <a href=
"#SSLSession"><code>SSLSession</code></a>.</p>
<a name="HandShakeCompletedListener" id=
"HandShakeCompletedListener"></a>
<h3><code>HandShakeCompletedListener</code> Interface</h3>
<p><code>javax.net.ssl.HandShakeCompletedListener</code> is an
interface implemented by any class which wants to receive
notification of the completion of an SSL protocol handshake on a
given <code>SSLSocket</code> connection.</p>
<a name="HandShakeCompletedEvent" id="HandShakeCompletedEvent"></a>
<h3><code>HandShakeCompletedEvent</code> Class</h3>
<p>A <code>javax.net.ssl.HandShakeCompletedEvent</code> is the
event communicated to a <a href=
"#HandShakeCompletedListener"><code>HandShakeCompletedListener</code></a>
upon completion of an SSL protocol handshake on a given
<code>SSLSocket</code> connection.</p>
<a name="HostnameVerifier" id="HostnameVerifier"></a>
<h3><code>HostnameVerifier</code> Interface</h3>
If the SSL/TLS implementation's standard hostname verification
logic fails, the implementation will call the <code>verify</code>
method of the class which implements this interface and is assigned
to this <code>HttpsURLConnection</code> instance. If the callback
class can determine that the hostname is acceptable given the
parameters, it should report that the connection should be allowed.
An unacceptable response will cause the connection to be
terminated.
<p>For example:</p>
<pre class="codeblock">
public class MyHostnameVerifier implements HostnameVerifier {

    public boolean verify(String hostname, SSLSession session) {
        // pop up an interactive dialog box
        // or insert additional matching logic
        if (good_address) {
            return true;
        } else {
            return false;
        }
    }
}

//...deleted...

HttpsURLConnection urlc = (HttpsURLConnection)
  (new URL("https://www.sun.com/")).openConnection();
urlc.setHostnameVerifier(new MyHostnameVerifier());
</pre>
See <a href="#HttpsURLConnection"><code>HttpsURLConnection</code>
Class</a> for more information on how to assign the
<code>HostnameVerifier</code> to the
<code>HttpsURLConnection</code>. <a name="X509Certificate" id=
"X509Certificate"></a>
<h3><code>X509Certificate</code> Class</h3>
<p>Many secure socket protocols perform authentication using public
key certificates, also called X.509 certificates. This is the
default authentication mechanism for the SSL and TLS protocols.</p>
<p>The <code>java.security.cert.X509Certificate</code> abstract
class provides a standard way to access the attributes of X.509
certificates.</p>
<p>Note: The
<code><b>javax</b>.security.cert.X509Certificate</code> class is
supported only for backward compatibility with previous (1.0.x and
1.1.x) versions of JSSE. New applications should use
<code><b>java</b>.security.cert.X509Certificate</code>, not
<code>javax.security.cert.X509Certificate</code>.</p>
<a name="AlgorithmConstraints" id="AlgorithmConstraints"></a>
<h3><code>AlgorithmConstraints</code> Interface</h3>
<p>The Java SE 7 release includes an interface,
<code>java.security.AlgorithmConstraints</code>, for controlling
allowed cryptographic algorithms. <code>AlgorithmConstraints</code>
defines three <code>permits()</code> methods. These methods tell
whether an algorithm name or a key is permitted for certain
cryptographic functions. Cryptographic functions are represented by
a set of <code>CryptoPrimitive</code>, which is an enumeration
containing fields like <code>STREAM_CIPHER</code>,
<code>MESSAGE_DIGEST</code>, <code>SIGNATURE</code>, and more.</p>
<p>Thus, an <code>AlgorithmConstraints</code> implementation can
answer questions like "Can I use this key with this algorithm for
the purpose of a cryptographic operation?"</p>
<p>An <code>AlgorithmConstraints</code> object can be associated
with an <code>SSLParameters</code> object using a new method,
<code>setAlgorithmConstraints()</code>. The current
<code>AlgorithmConstraints</code> object for an
<code>SSLParameters</code> object is retrieved with
<code>getAlgorithmConstraints()</code>.</p>
<a name="ConfigurationClasses" id="ConfigurationClasses"></a>
<h2>Previous (JSSE 1.0.x) Implementation Classes and
Interfaces</h2>
<p>In previous (1.0.x) versions of JSSE, there was a reference
implementation whose classes and interfaces were provided in the
<code>com.sun.net.ssl</code> package.</p>
<p>As of v1.4, JSSE has been integrated into the J2SDK. The classes
formerly in <code>com.sun.net.ssl</code> have been promoted to the
<code>javax.net.ssl</code> package and are now a part of the
standard JSSE API.</p>
<p>For compatibility purposes the <code>com.sun.net.ssl</code>
classes and interfaces still exist, but have been deprecated.
Applications written using them can run in the J2SDK v1.4 and later
without being recompiled. This may change in a future release;
these classes/interfaces may be removed. Thus, all new applications
should be written using the <code>javax</code>
classes/interfaces.</p>
<p>For now, applications written using the
<code>com.sun.net.ssl</code> API can utilize <i>either</i> JSSE
1.0.2 providers (ones using <code>com.sun.net.ssl</code>) <i>or</i>
JSSE providers written for the J2SDK v1.4 and later (ones using the
<code>javax</code> API). However, applications written using the
JSSE API in the J2SDK 1.4 and later can only utilize JSSE providers
written for the J2SDK 1.4 and later. There more recent releases
contain some new functionality and attempting to access such
functionality on a provider that doesn't supply it wouldn't work.
<code>SunJSSE</code>, provided with the JDK from Oracle, is a
provider written using the <code>javax</code> API.</p>
<p>You can still obtain a
<code>com.sun.net.ssl.HttpsURLConnection</code> if you update the
URL search path by setting the
<code>java.protocol.handler.pkgs</code> <code>System</code>
property as you did when using JSSE 1.0.2. For more information,
see <a href="#HttpsURLConnectionEx">Code Using
<code>HttpsURLConnection</code> Class...</a> in the Troubleshooting
section.</p>
<br />
<a name="InstallationAndCustomization" id=
"InstallationAndCustomization"></a>
<h1>Customizing JSSE</h1>
<a name="javaHome" id="javaHome"></a>
<h2>The Installation Directory &lt;java-home&gt;</h2>
<p>The term <code>&lt;java-home&gt;</code> is used throughout this
document to refer to the directory where the Java SE 6 Runtime
Environment (JRE) is installed. It is determined based on whether
you are running JSSE on a JRE with or without the Java SDK
installed. Java SE 6 SDK includes the JRE, but it is located in a
different level in the file hierarchy.</p>
<p>The following are some examples of which directories
<code>&lt;java-home&gt;</code> refers to:</p>
<ul>
<li>On Solaris, if the Java SE 6 SDK is installed in
<code>/home/user1/jdk1.6.0</code>, then
<code>&lt;java-home&gt;</code> is
<pre class="codeblock">
/home/user1/jdk1.6.0/jre
</pre></li>
<li>On Solaris, if JRE is installed in
<code>/home/user1/jre1.6.0</code> and the Java 2 SDK is <i>not</i>
installed, then <code>&lt;java-home&gt;</code> is
<pre class="codeblock">
/home/user1/jre1.6.0
</pre></li>
<li>On Microsoft Windows platforms, if the Java SE 6 SDK is
installed in <code>C:\jdk1.6.0</code>, then
<code>&lt;java-home&gt;</code> is
<pre class="codeblock">
C:\j2k1.6.0\jre
</pre></li>
<li>On Microsoft Windows platforms, if the JRE is installed in
<code>C:\jre1.6.0</code> and the Java SE 6 SDK is <i>not</i>
installed, then <code>&lt;java-home&gt;</code> is
<pre class="codeblock">
C:\jre1.6.0
</pre></li>
</ul>
<a name="Customization" id="Customization"></a>
<h2>Customization</h2>
<p>JSSE includes an implementation that all users can utilize. If
desired, it is also possible to customize a number of aspects of
JSSE, plugging in different implementations or specifying the
default keystore, and so on. The table that follows summarizes
which aspects can be customized, what the defaults are, and which
mechanisms are used to provide customization. The first column of
the table provides links to more detailed descriptions of each
designated aspect and how to customize it.</p>
<p>Some of the customizations are done by setting system property
or security property values. Sections following the table explain
how to set such property values.</p>
<hr />
<b>IMPORTANT NOTE: Many of the properties shown in this table are
currently utilized by the JSSE implementation, but there is no
guarantee that they will continue to have the same names and types
(system or security) or even that they will exist at all in future
releases. All such properties are flagged with an "*". They are
documented here for your convenience for use with the JSSE
implementation.</b>
<hr />
<b>JSSE Customization</b><br />
<br />
<table summary="JSSE customization" border="1" cellspacing="1"
cellpadding="7">
<thead>
<tr>
<th width="30%" valign="top">
<p class="c2">Customizable Item</p>
</th>
<th width="30%" valign="top">
<p class="c2">Default</p>
</th>
<th width="40%" valign="top">
<p class="c2">How To Customize</p>
</th>
</tr>
</thead>
<tbody>
<tr>
<td width="30%" valign="top"><a href=
"#X509CCust"><b>X509Certificate</b> implementation</a></td>
<td width="30%" valign="top">
<p>X509Certificate implementation from Oracle</p>
</td>
<td width="40%" valign="top">
<p><tt>cert.provider.x509v1</tt> security property</p>
</td>
</tr>
<tr>
<td width="30%" valign="top"><a href="#HTTPSCust"><b>HTTPS
protocol</b> implementation</a></td>
<td width="30%" valign="top">
<p>Implementation from Oracle</p>
</td>
<td width="40%" valign="top">
<p><tt>java.protocol.handler.pkgs</tt> system property</p>
</td>
</tr>
<tr>
<td width="30%" valign="top"><a href=
"#ProviderCust"><b>provider</b> implementation</a></td>
<td width="30%" valign="top">
<p>SunJSSE</p>
</td>
<td width="40%" valign="top">
<p>A <tt>security.provider.n=</tt> line in security properties
file. See description.</p>
</td>
</tr>
<tr>
<td width="30%" valign="top"><b>default <tt>SSLSocketFactory</tt>
implementation</b></td>
<td width="30%" valign="top">
<p><tt>SSLSocketFactory</tt> implementation from Oracle.</p>
</td>
<td width="40%" valign="top">
<p>** <tt>ssl.SocketFactory.provider</tt> security property</p>
</td>
</tr>
<tr>
<td width="30%" valign="top"><b>default
<tt>SSLServerSocketFactory</tt> implementation</b></td>
<td width="30%" valign="top">
<p><tt>SSLServerSocketFactory</tt> implementation from Oracle.</p>
</td>
<td width="40%" valign="top">
<p>** <tt>ssl.ServerSocketFactory.provider</tt> security
property</p>
</td>
</tr>
<tr>
<td width="30%" valign="top"><a href=
"#CustomizingStores"><b>default keystore</b></a></td>
<td width="30%" valign="top">
<p>No default.</p>
</td>
<td width="40%" valign="top">
<p>* <tt>javax.net.ssl.keyStore</tt> system property<br />
Note that the value <code>NONE</code> may be specified. This
setting is appropriate if the keystore is not file-based (for
example, it resides in a hardware token).</p>
</td>
</tr>
<tr>
<td width="30%" valign="top"><a href=
"#CustomizingStores"><b>default keystore password</b></a></td>
<td width="30%" valign="top">
<p>No default.</p>
</td>
<td width="40%" valign="top">
<p>* <tt>javax.net.ssl.keyStorePassword</tt> system property</p>
</td>
</tr>
<tr>
<td width="30%" valign="top"><a href=
"#CustomizingStores"><b>default keystore provider</b></a></td>
<td width="30%" valign="top">
<p>No default.</p>
</td>
<td width="40%" valign="top">
<p>* <tt>javax.net.ssl.keyStoreProvider</tt> system property</p>
</td>
</tr>
<tr>
<td width="30%" valign="top"><a href=
"#CustomizingStores"><b>default keystore type</b></a></td>
<td width="30%" valign="top">
<p><tt>KeyStore.getDefaultType()</tt></p>
</td>
<td width="40%" valign="top">
<p>* <tt>javax.net.ssl.keyStoreType</tt> system property</p>
</td>
</tr>
<tr>
<td width="30%" valign="top"><a href=
"#CustomizingStores"><b>default truststore</b></a></td>
<td width="30%" valign="top">
<p><code>jssecacerts</code>, if it exists. Otherwise,
<code>cacerts</code></p>
</td>
<td width="40%" valign="top">
<p>* <code>javax.net.ssl.trustStore</code> system property</p>
</td>
</tr>
<tr>
<td width="30%" valign="top"><a href=
"#CustomizingStores"><b>default truststore password</b></a></td>
<td width="30%" valign="top">
<p>No default.</p>
</td>
<td width="40%" valign="top">
<p>* <tt>javax.net.ssl.trustStorePassword</tt> system property</p>
</td>
</tr>
<tr>
<td width="30%" valign="top"><a href=
"#CustomizingStores"><b>default truststore provider</b></a></td>
<td width="30%" valign="top">
<p>No default.</p>
</td>
<td width="40%" valign="top">
<p>* <tt>javax.net.ssl.trustStoreProvider</tt> system property</p>
</td>
</tr>
<tr>
<td width="30%" valign="top"><a href=
"#CustomizingStores"><b>default truststore type</b></a></td>
<td width="30%" valign="top">
<p><tt>KeyStore.getDefaultType()</tt></p>
</td>
<td width="40%" valign="top">
<p>* <tt>javax.net.ssl.trustStoreType</tt> system property<br />
Note that the value <code>NONE</code> may be specified. This
setting is appropriate if the truststore is not file-based (for
example, it resides in a hardware token.)</p>
</td>
</tr>
<tr>
<td width="30%" valign="top"><a href="#DefaultKTMCust"><b>default
key manager factory algorithm name</b></a></td>
<td width="30%" valign="top">
<p><code>SunX509</code></p>
</td>
<td width="40%" valign="top">
<tt>ssl.KeyManagerFactory.algorithm</tt> security property</td>
</tr>
<tr>
<td width="30%" valign="top"><a href="#DefaultKTMCust"><b>default
trust manager factory algorithm name</b></a></td>
<td width="30%" valign="top">
<p><code>PKIX</code></p>
</td>
<td width="40%" valign="top">
<tt>ssl.TrustManagerFactory.algorithm</tt> security property</td>
</tr>
<tr>
<td width="30%" valign="top"><a href=
"#DisabledAlgorithms"><b>disabled certificate verification
cryptographic algorithms</b></a></td>
<td width="30%" valign="top">
<p><code>MD2, RSA keySize < 1024</code></p>
</td>
<td width="40%" valign="top">
<tt>jdk.certpath.disabledAlgorithms</tt> security property</td>
</tr>
<tr>
<td width="30%" valign="top"><a href=
"#DisabledAlgorithms"><b>disabled cipher suite cryptographic
algorithms</b></a></td>
<td width="30%" valign="top">
<p>No default.</p>
</td>
<td width="40%" valign="top"><tt>jdk.tls.disabledAlgorithms</tt>
security property</td>
</tr>
<tr>
<td width="30%" valign="top"><b>default proxy host</b></td>
<td width="30%" valign="top">
<p>No default.</p>
</td>
<td width="40%" valign="top">* <tt>https.proxyHost</tt> system
property</td>
</tr>
<tr>
<td width="30%" valign="top"><b>default proxy port</b></td>
<td width="30%" valign="top">
<p>80</p>
</td>
<td width="40%" valign="top">* <tt>https.proxyPort</tt> system
property</td>
</tr>
<tr>
<td width="30%" valign="top"><b>Server Name Indication
option</b></td>
<td width="30%" valign="top">
<p><code>true</code></p>
</td>
<td width="40%" valign="top">* <tt>jsse.enableSNIExtension</tt>
system property. Server Name Indication (SNI) is a TLS extension,
defined in <a href="http://www.ietf.org/rfc/rfc4366.txt">RFC
4366</a>. It enables TLS connections to virtual servers, in which
multiple servers for different network names are hosted at a single
underlying network address.<br />
<br />
Some very old SSL/TLS vendors may not be able handle SSL/TLS
extensions. In this case, set this property to <code>false</code>
to disable the SNI extension.</td>
</tr>
<tr>
<td width="30%" valign="top"><b>default ciphersuites</b></td>
<td width="30%" valign="top">
<p>Determined by the socket factory.</p>
</td>
<td width="40%" valign="top">* <tt>https.cipherSuites</tt> system
property. This contains a comma-separated list of cipher suite
names specifying which cipher suites to enable for use on this
<code>HttpsURLConnection</code>. See the <a href=
"../../../../api/javax/net/ssl/SSLSocket.html#setEnabledCipherSuites(java.lang.String%5B%5D)">
<code>SSLSocket setEnabledCipherSuites(String[])</code></a>
method.</td>
</tr>
<tr>
<td width="30%" valign="top"><b>default handshaking
protocols</b></td>
<td width="30%" valign="top">
<p>Determined by the socket factory</p>
</td>
<td width="40%" valign="top">* <tt>https.protocols</tt> system
property. This contains a comma-separated list of protocol suite
names specifying which protocol suites to enable on this
<code>HttpsURLConnection</code>. See the <a href=
"../../../../api/javax/net/ssl/SSLSocket.html#setEnabledProtocols(java.lang.String%5B%5D)">
<tt>SSLSocket setEnabledProtocols(String[])</tt></a> method.</td>
</tr>
<tr>
<td width="30%" valign="top"><b>default https port</b></td>
<td width="30%" valign="top">
<p>443</p>
</td>
<td width="40%" valign="top">* Customize via <code>port</code>
field in the https URL.</td>
</tr>
<tr>
<td width="30%" valign="top"><a href="#JCECust"><b>JCE encryption
algorithms used by SunJSSE provider</b></a></td>
<td width="30%" valign="top">
<p>SunJCE implementations</p>
</td>
<td width="40%" valign="top">Give alternate JCE algorithm
provider(s) a higher preference order than the SunJCE provider</td>
</tr>
<tr>
<td width="30%" valign="top"><b>default sizing buffers for large
SSL/TLS packets</b></td>
<td width="30%" valign="top">
<p>No default.</p>
</td>
<td width="40%" valign="top">
<p>* <tt>jsse.SSLEngine.acceptLargeFragments</tt> system
property<br />
By setting this system property to <code>true</code>, SSLSession
will size buffers to handle <a href="#LargePackets">large data
packets</a> by default. This may cause applications to allocate
unnecessarily large SSLEngine buffers. Instead, applications should
<a href="#OperationStatus">dynamically check for buffer overflow
conditions</a> and resize buffers as appropriate.</p>
</td>
</tr>
<tr>
<td width="30%" valign="top"><b><a href="#descPhase2">Allow Unsafe
SSL/TLS Renegotiations</a></b></td>
<td><code>false</code></td>
<td>* <code>sun.security.ssl.allowUnsafeRenegotiation</code> system
property.<br />
Setting this system property to <code>true</code> permits full
(unsafe) legacy renegotiation.</td>
</tr>
<tr>
<td width="30%" valign="top"><b><a href="#descPhase2">Allow Legacy
Hello Messages (Renegotiations)</a></b></td>
<td><code>true</code></td>
<td>* <code>sun.security.ssl.allowLegacyHelloMessages</code> system
property.<br />
Setting this system property to <code>true</code> allows the peer
to handshake without requiring the proper RFC 5746 messages.</td>
</tr>
</tbody>
</table>
<p>* This property is currently used by the JSSE implementation. It
is not guaranteed to be examined and used by other implementations.
If it <i>is</i> examined by another implementation, that
implementation should handle it in the same manner as the JSSE
implementation does. There is no guarantee the property will
continue to exist or be of the same type (system or security) in
future releases.</p>
<a name="SystemProps" id="SystemProps"></a>
<p>Note that some items are customized by setting
<code>java.lang.System</code> properties while others are
customized by setting <code>java.security.Security</code>
properties. The following sections explain how to set values for
both types of properties.</p>
<h3>How to Specify a <code>java.lang.System</code> Property</h3>
<p>Some aspects of JSSE may be customized by setting system
properties. There are several ways to set these properties:</p>
<ul>
<li>
<p>To set a system property statically, use the <code>-D</code>
option of the <code>java</code> command. For example, to run an
application named <code>MyApp</code> and set the
<code>javax.net.ssl.trustStore</code> system property to specify a
<a href="#CustomizingStores">truststore</a> named
"<code>MyCacertsFile</code>", type the following:</p>
<pre class="codeblock">
java -Djavax.net.ssl.trustStore=MyCacertsFile MyApp
</pre></li>
<li>
<p>To set a system property dynamically, call the
<code>java.lang.System.setProperty</code> method in your code:</p>
<pre class="codeblock">
System.setProperty(<i>propertyName</i>, "<i>propertyValue</i>");
</pre>
<p>substituting the appropriate property name and value. For
example, a <code>setProperty</code> call corresponding to the
previous example for setting the
<code>javax.net.ssl.trustStore</code> system property to specify a
truststore named "<code>MyCacertsFile</code>" would be:</p>
<pre class="codeblock">
System.setProperty("javax.net.ssl.trustStore", "MyCacertsFile");
</pre></li>
<li>
<p>In the Java Deployment environment (Plug-In/Web Start), there
are several ways to set the system properties. (See <a href=
"../../jweb/">Java Rich Internet Applications Development and
Deployment</a> for more information.)</p>
<ul>
<li>
<p>Use the Java Control Panel to set the Runtime Environment
Property on a local/per-VM basis. This creates a local
<code>deployment.properties</code> file. Deployers can also
distribute a enterprise-wide <code>deployment.properties</code>
file by using the <code>deployment.config</code> mechanism. (See
<a href=
"../../deployment/deployment-guide/properties.html">Deployment
Configuration File and Properties</a>.)</p>
</li>
<li>
<p>To set a property for a specific applet, use the HTML subtag
<code>&lt;PARAM&gt;</code> "java_arguments" within the
<code>&lt;APPLET&gt;</code> tag. (See <a href=
"../../jweb/applet/applet_deployment.html#JAVA_ARGUMENTS">java
arguments</a>.)</p>
</li>
<li>
<p>To set the property in a specific Java Web Start application or
applet using the new Plugin2 (6u10+), use the JNLP "property"
sub-element of the "resources" element. (See <a href=
"../../javaws/developersguide/syntax.html#resources"><code>resources</code>
Element</a>.)</p>
</li>
</ul>
</li>
</ul>
<a name="SecurityProps" id="SecurityProps"></a>
<h3>How to Specify a <code>java.security.Security</code>
Property</h3>
<p>Some aspects of JSSE may be customized by setting security
properties. You can set a security property either statically or
dynamically:</p>
<ul>
<li>To set a security property statically, add a line to the
security properties file. The security properties file is located
at:
<pre class="codeblock">
&lt;java-home&gt;/lib/security/java.security
</pre>
where <tt>&lt;java-home&gt;</tt> refers to the directory where the
JRE runtime software is installed, as described in <a href=
"#javaHome">The Installation Directory &lt;java-home&gt;</a>.
<p>To specify a security property value in the security properties
file, you add a line of the following form:</p>
<pre class="codeblock">
<i>propertyName</i>=<i>propertyValue</i>
</pre>
<p>For example, suppose you want to specify a different key manager
factory algorithm name than the "SunX509" default. You do this by
specifying the algorithm name as the value of a security property
named <code>ssl.KeyManagerFactory.algorithm</code>. Suppose you
want to set the value to "MyX509". To do so, place the following in
the security properties file:</p>
<pre class="codeblock">
ssl.KeyManagerFactory.algorithm=MyX509
</pre></li>
<li>To set a security property dynamically, call the
<code>java.security.Security.setProperty</code> method in your
code:
<pre class="codeblock">
Security.setProperty(<i>propertyName</i>,
    "<i>propertyValue</i>");
</pre>
substituting the appropriate property name and value. For example,
a <code>setProperty</code> call corresponding to the previous
example for specifying the key manager factory algorithm name would
be:
<pre class="codeblock">
Security.setProperty("ssl.KeyManagerFactory.algorithm",
    "MyX509");
</pre></li>
</ul>
<a name="X509CCust" id="X509CCust"></a>
<h3>Customizing the X509Certificate Implementation</h3>
<p>The X509Certificate implementation returned by the
<code>X509Certificate.getInstance</code> method is by default the
implementation from the JSSE implementation.</p>
<p>You can optionally cause a different implementation to be
returned. To do so, specify the name (and package) of the alternate
implementation's class as the value of a <a href=
"#SecurityProps">security property</a> named
<code>cert.provider.x509v1</code>. For example, if the class is
called <code>MyX509CertificateImpl</code> and it appears in the
<code>com.cryptox</code> package, you should place the following in
the security properties file:</p>
<pre class="codeblock">
cert.provider.x509v1=com.cryptox.MyX509CertificateImpl
</pre>
<a name="HTTPSCust" id="HTTPSCust"></a>
<h3>Specifying an Alternate HTTPS Protocol Implementation</h3>
<p>You can communicate securely with an SSL-enabled web server by
using the "https" URL scheme for the <code>java.net.URL</code>
class. The JDK provides a default https URL implementation.</p>
<p>If you want an alternate https protocol implementation to be
used, set the <code>java.protocol.handler.pkgs</code> <a href=
"#SystemProps">system property</a> to include the new class name.
This action causes the specified classes to be found and loaded
before the JDK default classes. See the <code>java.net.URL</code>
class documentation for details.</p>
<p><b>Note to previous JSSE users:</b> In past Sun JSSE releases,
you had to set the <code>java.protocol.handler.pkgs</code> system
property during JSSE installation. This step is no longer required
unless you wish to obtain an instance of
<code>com.sun.net.ssl.HttpsURLConnection</code>. For more
information, see <a href="#HttpsURLConnectionEx">Code Using
<code>HttpsURLConnection</code> Class...</a> in the Troubleshooting
section.</p>
<a name="ProviderCust" id="ProviderCust"></a>
<h3>Customizing the Provider Implementation</h3>
<p>The J2SDK 1.4 and later releases come standard with a JSSE
Cryptographic Service Provider, or <i>provider</i> for short, named
"<code>SunJSSE</code>". Providers are essentially packages that
implement one or more engine classes for specific cryptographic
algorithms. The JSSE engine classes are <code>SSLContext</code>,
<code>KeyManagerFactory</code>, and
<code>TrustManagerFactory</code>. For more information on providers
and engine classes, see the "Design Principles" and "Concepts"
sections of the <a href="../crypto/CryptoSpec.html">Java
Cryptography Architecture Reference Guide</a>.</p>
<p>In order to be used, a provider must be registered, either
statically or dynamically. You do not need to register the
"SunJSSE" provider because it is pre-registered. If you want to use
other providers, read the following sections to see how to register
them.</p>
<h4>Registering the Cryptographic Service Provider Statically</h4>
You register a provider statically by adding a line of the
following form to the <a href="#SecurityProps">security properties
file</a>:
<pre class="codeblock">
security.provider.<i>n</i>=<i>providerClassName</i>
</pre>
<p>This declares a provider, and specifies its preference order
"n". The preference order is the order in which providers are
searched for requested algorithms (when no specific provider is
requested). The order is 1-based; 1 is the most preferred, followed
by 2, and so on.</p>
<p>The <i>providerClassName</i> is the fully qualified name of the
provider class. You get this name from the provider vendor.</p>
<p>To register a provider, add the above line to the security
properties file, replacing <i>providerClassName</i> with the fully
qualified name of the provider class and substituting <i>n</i> with
the priority that you would like to assign to the provider.</p>
<p>The standard security provider and the SunJSSE provider shipped
with the Java SE 6 platform are automatically registered for you;
the following lines appear in the <code>java.security</code>
security properties file to register the SunJCE security provider
with preference order 5 and the SunJSSE provider with preference
order 4:</p>
<pre class="codeblock">
          security.provider.1=sun.security.pkcs11.SunPKCS11 \
              ${java.home}/lib/security/sunpkcs11-solaris.cfg
          security.provider.2=sun.security.provider.Sun
          security.provider.3=sun.security.rsa.SunRsaSign
          security.provider.4=com.sun.net.ssl.internal.ssl.Provider
          security.provider.5=com.sun.crypto.provider.SunJCE
          security.provider.6=sun.security.jgss.SunProvider
          security.provider.7=com.sun.security.sasl.Provider
</pre>
<p>To utilize another JSSE provider, add a line registering the
alternate provider, giving it whatever preference order you
prefer.</p>
<p>You can have more than one JSSE provider registered at the same
time. They may include different implementations for different
algorithms for different engine classes, or they may have support
for some or all of the same types of algorithms and engine classes.
When a particular engine class implementation for a particular
algorithm is searched for, if no specific provider is specified for
the search, the providers are searched in preference order and the
implementation from the first provider that supplies an
implementation for the specified algorithm is used.</p>
<h4>Registering the Cryptographic Service Provider Dynamically</h4>
<p>Instead of registering a provider statically, you can add the
provider dynamically at runtime by calling the
<code>Security.addProvider</code> method at the beginning of your
program. For example, to dynamically add a provider whose Provider
class name is <code>MyProvider</code> and whose
<code>MyProvider</code> class resides in the <code>com.ABC</code>
package, you would call:</p>
<pre class="codeblock">
Security.addProvider(
  new com.ABC.MyProvider());
</pre>
<p>The <code>Security.addProvider</code> method adds the specified
provider to the next available preference position.</p>
<p>This type of registration is not persistent and can only be done
by a program with sufficient permissions.</p>
<a name="CustomizingStores" id="CustomizingStores"></a>
<h3>Customizing the Default Key and Trust Stores, Store Types, and
Store Passwords</h3>
<p>Whenever a default <code>SSLSocketFactory</code> or
<code>SSLServerSocketFactory</code> is created (via a call to
<code>SSLSocketFactory.getDefault</code> or
<code>SSLServerSocketFactory.getDefault</code>), and this default
<code>SSLSocketFactory</code> (or
<code>SSLServerSocketFactory</code>) comes from the JSSE reference
implementation, a default <code>SSLContext</code> is associated
with the socket factory. (The default socket factory will come from
the JSSE implementation.)</p>
<p>This default <code>SSLContext</code> is initialized with a
default <code>KeyManager</code> and a <code>TrustManager</code>. If
a keystore is specified by the <code>javax.net.ssl.keyStore</code>
<a href="#SystemProps">system property</a> and an appropriate
<code>javax.net.ssl.keyStorePassword</code> <a href=
"#SystemProps">system property</a>, then the
<code>KeyManager</code> created by the default
<code>SSLContext</code> will be a <code>KeyManager</code>
implementation for managing the specified keystore. (The actual
implementation will be as specified in <a href=
"#DefaultKTMCust">Customizing the Default Key and Trust
Managers</a>.) If no such system property is specified, then the
keystore managed by the <code>KeyManager</code> will be a new empty
keystore.</p>
<p>Generally, the peer acting as the server in the handshake will
need a keystore for its KeyManager in order to obtain credentials
for authentication to the client. However, if one of the anonymous
cipher suites is selected, the server's <code>KeyManager</code>
keystore is not necessary. And, unless the server requires client
authentication, the peer acting as the client will not need a
<code>KeyManager</code> keystore. Thus, in these situations it may
be okay if there is no <code>javax.net.ssl.keyStore</code> system
property value defined.</p>
<p>Similarly, if a truststore is specified by the
<code>javax.net.ssl.trustStore</code> system property, then the
<code>TrustManager</code> created by the default
<code>SSLContext</code> will be a <code>TrustManager</code>
implementation for managing the specified truststore. In this case,
if such a property exists but the file it specifies doesn't, then
no truststore is utilized. If no
<code>javax.net.ssl.trustStore</code> property exists, then a
default truststore is searched for. If a truststore named
<code>&lt;java-home&gt;/lib/security/jssecacerts</code> is found,
it is used. If not, then a truststore named
<code>&lt;java-home&gt;/lib/security/cacerts</code> is searched for
and used (if it exists). See <a href="#javaHome">The Installation
Directory &lt;java-home&gt;</a> for information as to what
<code>&lt;java-home&gt;</code> refers to. Finally, if a truststore
is still not found, then the truststore managed by the
<code>TrustManager</code> will be a new empty truststore.</p>
<hr />
<b>IMPORTANT NOTE: The JDK ships with a limited number of trusted
root certificates in the
<code>&lt;java-home&gt;/lib/security/cacerts</code> file. As
documented in <a href=
"../../../tools/index.html#security">keytool</a>, it is your
responsibility to maintain (that is, add/remove) the certificates
contained in this file if you use this file as a truststore.</b>
<p class="c3">Depending on the certificate configuration of the
servers you contact, you may need to add additional root
certificate(s). Obtain the needed specific root certificate(s) from
the appropriate vendor.</p>
<hr />
<p>If system properties <code>javax.net.ssl.keyStoreType</code>
and/or <code>javax.net.ssl.keyStorePassword</code> are also
specified, they are treated as the default <code>KeyManager</code>
keystore type and password, respectively. If there is no type
specified, the default type is that returned by
<code>KeyStore.getDefaultType()</code>, which is the value of the
<code>keystore.type</code> security property, or "jks" if no such
security property is specified. If there is no keystore password
specified, it is assumed to be "".</p>
<p>Similarly, if system properties
<code>javax.net.ssl.trustStoreType</code> and/or
<code>javax.net.ssl.trustStorePassword</code> are also specified,
they are treated as the default truststore type and password,
respectively. If there is no type specified, the default type is
that returned by <code>KeyStore.getDefaultType()</code>. If there
is no truststore password specified, it is assumed to be "".</p>
<p><b>Important Note:</b> This section describes the current JSSE
reference implementation behavior. The system properties described
in this section are not guaranteed to continue to have the same
names and types (system or security) or even to exist at all in
future releases. They are also not guaranteed to be examined and
used by any other JSSE implementations. If they <i>are</i> examined
by an implementation, that implementation should handle them in the
same manner as the JSSE reference implementation does, as described
herein.</p>
<a name="DefaultKTMCust" id="DefaultKTMCust"></a>
<h3>Customizing the Default Key and Trust Managers</h3>
<p>As noted in <a href="#CustomizingStores">Customizing the Default
Key and Trust Stores, Store Types, and Store Passwords</a>,
whenever a default <code>SSLSocketFactory</code> or
<code>SSLServerSocketFactory</code> is created, and this default
<code>SSLSocketFactory</code> (or
<code>SSLServerSocketFactory</code>) comes from the JSSE reference
implementation, a default <code>SSLContext</code> is associated
with the socket factory.</p>
<p>This default <code>SSLContext</code> is initialized with a
<code>KeyManager</code> and a <code>TrustManager</code>. The
<code>KeyManager</code> and/or <code>TrustManager</code> supplied
to the default <code>SSLContext</code> will be a
<code>KeyManager</code>/<code>TrustManager</code> implementation
for managing the specified keystore/truststore, as described in the
aforementioned section.</p>
<p>The <code>KeyManager</code> implementation chosen is determined
by first examining the</p>
<pre class="codeblock">
ssl.KeyManagerFactory.algorithm
</pre>
<a href="#SecurityProps">security property</a>. If such a property
value is specified, a <code>KeyManagerFactory</code> implementation
for the specified algorithm is searched for. The implementation
from the first provider that supplies an implementation is used.
Its <code>getKeyManagers</code> method is called to determine the
<code>KeyManager</code> to supply to the default
<code>SSLContext</code>. (Technically, <code>getKeyManagers</code>
returns an array of <code>KeyManager</code>s, one
<code>KeyManager</code> for each type of key material.) If there is
no such security property value specified, the default value of
"SunX509" is used to perform the search. Note: A
<code>KeyManagerFactory</code> implementation for the "SunX509"
algorithm is supplied by the <code>SunJSSE</code> provider. The
<code>KeyManager</code> it specifies is a
<code>javax.net.ssl.X509KeyManager</code> implementation.
<p>Similarly, the <code>TrustManager</code> implementation chosen
is determined by first examining the</p>
<pre class="codeblock">
ssl.TrustManagerFactory.algorithm
</pre>
security property. If such a property value is specified, a
<code>TrustManagerFactory</code> implementation for the specified
algorithm is searched for. The implementation from the first
provider that supplies an implementation is used. Its
<code>getTrustManagers</code> method is called to determine the
<code>TrustManager</code> to supply to the default
<code>SSLContext</code>. (Technically,
<code>getTrustManagers</code> returns an array of
<code>TrustManager</code>s, one <code>TrustManager</code> for each
type of trust material.) If there is no such security property
value specified, the default value of "PKIX" is used to perform the
search. Note: A <code>TrustManagerFactory</code> implementation for
the "PKIX" algorithm is supplied by the <code>SunJSSE</code>
provider. The <code>TrustManager</code> it specifies is a
<code>javax.net.ssl.X509TrustManager</code> implementation.
<p><b>Important Note:</b> This section describes the current JSSE
reference implementation behavior. The system properties described
in this section are not guaranteed to continue to have the same
names and types (system or security) or even to exist at all in
future releases. They are also not guaranteed to be examined and
used by any other JSSE implementations. If they <i>are</i> examined
by an implementation, that implementation should handle them in the
same manner as the JSSE reference implementation does, as described
herein.</p>
<a name="DisabledAlgorithms" id="DisabledAlgorithms"></a>
<h3>Disabled Cryptographic Algorithms</h3>
<p>The cryptographic hash algorithm MD2 is no longer considered
secure. The Java SE 7 release includes two new security properties
and a new API that support disabling specific cryptographic
algorithms.</p>
<p>The <code>jdk.tls.disabledAlgorithms</code> property applies to
TLS handshaking, while the <code>jdk.certpath.disabledAlgorithms</code> 
property applies to certification path processing.</p>

<!--<p>For example, the default value of <code>jdk.certpath.disabledAlgorithms</code> is 
<code>MD2</code>. This means that any certificate signed with MD2 is not
acceptable.</p>-->

<p>Starting from JDK 7u40 release, the default value of 
<code>jdk.certpath.disabledAlgorithms</code> includes <code>RSA keySize < 1024</code>. 
This means the use of certificates with RSA key size less than 1024 bits in length is 
restricted. The default value of <code>jdk.certpath.disabledAlgorithms</code> is now as 
follows:</p>

<pre class="codeblock">
    jdk.certpath.disabledAlgorithms=MD2, RSA keySize &lt; 1024
</pre>

<p>This means that any certificate signed with MD2 or with a RSA key of size < 1024, is not acceptable.</p>


<p>Each security property contains a list of cryptographic
algorithms that will not be used during certification path
processing. The exact syntax of the properties is described in the
<code>jre/lib/security/java.security</code> file, but is briefly
summarized here.</p>
<p>The security property contains a list of cryptographic
algorithms that must not be used. The algorithm names are separated
by commas. Furthermore, you can also specify certain key sizes that
cannot be used.</p>
<p>For example, the following line in <code>java.security</code>
specifies that the MD2 and DSA algorithms must not be used for
certification path processing. Furthermore, RSA is disabled for key
sizes less than 2048 bits.</p>
<pre class="codeblock">
jdk.certpath.disabledAlgorithms=MD2, DSA, RSA keySize &lt; 2048
</pre>
<a name="JCECust" id="JCECust"></a>
<h3>Customizing the Encryption Algorithm Providers</h3>
<p>As of the Java SE 5 release, the SunJSSE provider uses the
SunJCE implementation for all its cryptographic needs. While it is
recommended that you leave the Sun provider at its regular
position, you can use implementations from other JCA/JCE providers
by registering them <b>before</b> the SunJCE provider. The <a href=
"../crypto/CryptoSpec.html#ProviderImplReq">standard JCA
mechanism</a> can be used to configure providers, either statically
via the security properties file</p>
<pre class="codeblock">
&lt;java-home&gt;/lib/security/java.security
</pre>
or dynamically via the <code>addProvider</code> or
<code>insertProviderAt</code> method in the
<code>java.security.Security</code> class. (See <a href=
"#javaHome">The Installation Directory &lt;java-home&gt;</a> for
information about what <code>&lt;java-home&gt;</code> refers to.)
<h3>Note for People Implementing Providers</h3>
<p>The transformation strings used when SunJSSE calls
<code>Cipher.getInstance()</code> are "RSA/ECB/PKCS1Padding",
"RC4", "DES/CBC/NoPadding", and "DESede/CBC/NoPadding". For further
information on the Cipher class and transformation strings see the
<a href="../crypto/CryptoSpec.html">Cryptography
Specification</a>.</p>
<a name="tlsRenegotiation" id="tlsRenegotiation"></a> 
<!-- ******************************** -->
<h1>Transport Layer Security (TLS) Renegotiation Issue</h1>
<a name="intro" id="intro"></a>
<h2>Introduction</h2>
<p>In the Fall of 2009, a flaw was discovered in the SSL/TLS
protocols. A fix to the protocol was developed by the IETF TLS
Working Group, and current versions of the JDK contain this fix.
This section describes the situation in much more detail, along
with interoperability issues when communicating with the older
implementations which to not contain this protocol fix.</p>
<p>The vulnerability allowed for Man-In-The-Middle (MITM) type
attacks where chosen plain text could be injected as a prefix to a
TLS connection. This vulnerability does not allow an attacker to
decrypt or modify the intercepted network communication once the
client and server have successfully negotiated a session between
themselves.</p>
<p>Additional information is available at:</p>
<ul>
<li><a href=
"http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3555"
target="_blank">CVE-2009-3555</a> - posted on Mitre's <a href=
"http://cve.mitre.org/index.html" target="_blank">Common
Vulnerabilities and Exposures List</a>, 2009.</li>
<li><a href=
"http://www.educatedguesswork.org/2009/11/understanding_the_tls_renegoti.html"
target="_blank">Understanding the TLS Renegotiation Attack</a> -
posted on Eric Rescorla's blog, <a href=
"http://www.educatedguesswork.org/" target="_blank">Educated
Guesswork</a>, November 5th, 2009.</li>
</ul>
<a name="phased" id="phased"></a>
<h2>Phased Approach To Fixing This Issue</h2>
<p>The fix for this issue was handled in two phases:</p>
<ul>
<li>
<p>Phase 1: Until a protocol fix could be developed, an interim fix
which disabled SSL/TLS renegotiations by default, was made
available in the <a href=
"http://www.oracle.com/technetwork/topics/security/javacpumar2010-083341.html">
March 30, 2010 Java SE and Java for Business Critical Patch
Update</a>.</p>
</li>
<li>
<p>Phase 2: The <a href="http://www.ietf.org/">IETF</a> issued
<a href="http://www.ietf.org/rfc/rfc5746.txt">RFC 5746</a> which
addresses the renegotiation protocol flaw. A fix which implements
RFC 5746 and supports secure renegotiation is included in the
following releases:</p>
</li>
</ul>
<table border="1" summary=
"Release that include fix that implements RFC 5746 and supports secure renegotiation">
<tr>
<th>JDK Family</th>
<th>Vulnerable<br />
Releases</th>
<th>Phase 1 Fix<br />
(Disable Reneg.)</th>
<th>Phase 2 Fix<br />
(RFC 5746)</th>
</tr>
<tr>
<td>JDK and JRE 6</td>
<td>Update 18 and earlier</td>
<td>Updates 19-21</td>
<td>Update 22</td>
</tr>
<tr>
<td>JDK and JRE 5.0</td>
<td>Update 23 and earlier</td>
<td>Updates 24-25</td>
<td>Update 26</td>
</tr>
<tr>
<td>SDK and JRE 1.4.2</td>
<td>Update 25 and earlier</td>
<td>Updates 26-27</td>
<td>Update 28</td>
</tr>
</table>
<p><b>NOTE:</b> In the Phase 2 default configuration, there is no
impact to applications that do not require renegotiations.
Applications that require a renegotiation (e.g. web servers that
initially allow for anonymous client browsing, but later require
SSL/TLS authenticated clients):</p>
<ul>
<li>will not be impacted if the peer is also RFC
5746-compliant.</li>
<li>will be impacted if the peer has not been upgraded to RFC 5746
(see next section for details).</li>
</ul>
<a name="descPhase2" id="descPhase2"></a>
<h2>Description of Phase 2 Fix</h2>
<p>The SunJSSE implementation re-enables renegotiations by default
for connections to RFC 5746 compliant peers. That is, both the
client and server <b>must support RFC 5746</b> in order to securely
renegotiate. SunJSSE provides some interoperability modes for
connections with peers that have not been upgraded, but users are
<b>strongly encouraged to update both their client and server
implementations as soon as possible</b>.</p>
<p>With the Phase 2 fix, SunJSSE now has three "renegotiation
interoperability modes." Each mode fully supports RFC 5746's secure
renegotiation, but has these added semantics when communicating
with an unupgraded peer:</p>
<ol>
<li>
<p><b>Strict mode</b>: Requires both client and server be upgraded
to RFC 5746 and send the proper RFC 5746 messages. If not, the
initial (or subsequent) handshaking will fail and the connection
will be terminated.</p>
</li>
<li>
<p><b>Interoperable mode (default)</b> : Use of the proper RFC 5746
messages is optional, however legacy (original SSL/TLS
specifications) renegotiations are disabled if the proper messages
are not used. Initial legacy connections are still allowed, but
legacy renegotiations are disabled. This is the best mix of
security and interoperability, and is the default setting.</p>
</li>
<li>
<p><b>Insecure mode</b>: Permits full legacy renegotiation. Most
interoperable with legacy peers but vulnerable to the original MITM
attack.</p>
</li>
</ol>
<p>The mode distinctions above only affect a connection with an
unupgraded peer. Ideally, strict (full RFC 5746) mode should be
used for all clients/servers, however it will take some time for
all deployed SSL/TLS implementations to support RFC 5746, thus the
interoperable mode will be the default for now.</p>
<p>Here is some additional interoperability information:</p>
<table border="1" summary="Interoperability information">
<tr>
<th>Client</th>
<th>Server</th>
<th>Mode</th>
</tr>
<tr>
<td>Updated</td>
<td>Updated</td>
<td>Secure Renegotiation in all modes.</td>
</tr>
<tr>
<td>Legacy[1]</td>
<td>Updated</td>
<td>
<ul>
<li><strong>Strict</strong>: If clients do not send the proper RFC
5746 messages, initial connections will immediately be terminated
by the server
(<code>SSLHandshakeException</code>/handshake_failure).</li>
<li><strong>Interoperable</strong>: Initial connections from legacy
clients allowed (missing RFC 5746 messages), but renegotiations
will not be allowed by the server. [2][3]</li>
<li><strong>Insecure</strong>: Connections and renegotiations with
legacy clients are allowed, but are vulnerable to the original MITM
attack.</li>
</ul>
</td>
</tr>
<tr>
<td>Updated</td>
<td>Legacy[1]</td>
<td>
<ul>
<li><strong>Strict</strong>: If the server does not respond with
the proper RFC 5746 messages, the client will immediately terminate
the connection
(<code>SSLHandshakeException/handshake_failure</code>).</li>
<li><strong>Interoperable</strong>: The client will not require the
proper initial RFC 5746 message from the server, but renegotiations
will not be allowed by the client. [2][3]</li>
<li><strong>Insecure</strong>: Connections and renegotiations with
legacy clients are allowed, but are vulnerable to the original MITM
attack.</li>
</ul>
</td>
</tr>
<tr>
<td align="center">Legacy[1]</td>
<td align="center">Legacy[1]</td>
<td>Existing SSL/TLS behavior, vulnerable to the MITM attack.</td>
</tr>
</table>
<p>[1] Legacy means the original SSL/TLS specifications (i.e.
non-RFC 5746).</p>
<p>[2] SunJSSE Phase 1 implementations (see above) reject
renegotiations unless specifically re-enabled. If renegotiations are
reenabled, they will be treated as Legacy by the RFC 5746-compliant
peer since they do not send the proper RFC 5746 messages.</p>
<p>[3] In SSL/TLS, renegotiations can be initiated by either side.
Like the Phase 1 fix, applications communicating with an unupgraded
peer in Interoperable mode and that attempt to initiate
renegotiation (via <code>SSLSocket.startHandshake()</code> or
<code>SSLEngine.beginHandshake()</code>) will receive a
<code>SSLHandshakeException</code> (<code>IOException</code>) and
the connection will be shutdown (handshake_failure). Applications
that receive a renegotiation request from a non-upgraded peer will
respond according to the type of connection in place:</p>
<ul>
<li>TLSv1: A warning Alert message of type "no_renegotiation(100)"
will be sent to the peer and the connection will remain open. Older
versions of SunJSSE will shutdown the connection when a
"no_renegotiation" Alert is received.</li>
<li>SSLv3: The application will receive a
<code>SSLHandshakeException</code>, and the connection will be
closed (handshake_failure). ("no_renegotiation" is not defined in
the SSLv3 spec.)</li>
</ul>
<p>To set these modes, two system properties are used:</p>
<ul>
<li><code><b>sun.security.ssl.allowUnsafeRenegotiation</b></code>
Introduced in Phase 1, this controls whether legacy (unsafe)
renegotiations are permitted.</li>
<li><code><b>sun.security.ssl.allowLegacyHelloMessages</b></code>
Introduced in Phase 2, this allows the peer to handshake without
requiring the proper RFC 5746 messages.</li>
</ul>
<table border="1" summary=
"System properties to set interoperability modes">
<tr>
<th>mode</th>
<th>allowLegacyHelloMessages</th>
<th>allowUnsafeRenegotiation</th>
</tr>
<tr>
<td>Strict</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>Interoperable (default)</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>Insecure</td>
<td>true</td>
<td>true</td>
</tr>
</table>
<p><b>WARNING:</b> It is not recommended to re-enable the insecure
SSL/TLS renegotiation, as the vulnerability is once again
present.</p>
For information on how to configure a specific mode by setting a
system property, see <a href="#SystemProps">How to Specify a
<code>java.lang.System</code> Property</a>. <a name="workarounds"
id="workarounds"></a>
<h2>Workarounds/Alternatives to SSL/TLS Renegotiation</h2>
<p>All peers should be updated to RFC 5746-compliant implementation
as soon as possible. Even with this RFC 5746 fix, communications
with unupgraded peers will be impacted if a renegotiation is
necessary. Here are a few suggested options:</p>
<ul>
<li>
<p>Restructure the peer to not require renegotiation.</p>
<p>Renegotiations are typically used by web servers that initially
allow for anonymous client browsing but later require SSL/TLS
authenticated clients, or which may initially allow weak
ciphersuites but later need stronger ones. The alternative is to
require client authentication/strong ciphersuites during the
<b>initial</b> negotiation. There are a couple of options for doing
so:</p>
<ul>
<li>
<p>If an application has a "browse mode" until a certain point is
reached and a renegotiation is required, one can restructure the
server to eliminate the "browse mode" and require all initial
connections be strong.</p>
</li>
<li>
<p>Another alternative is to break the server into two entities,
with the "browse mode" occurring on server, and a second for the
more secure mode. When the point is reached, transfer any relevant
information between the servers and.</p>
</li>
</ul>
<p>Both of these options couple require a fair amount of work, but
will not reopen the original hole.</p>
</li>
<li>
<p>Set renegotiation interoperability mode to "insecure" using the
system properties (see above for information and warnings).</p>
</li>
</ul>
<a name="implDetails" id="implDetails"></a>\
<h2>Implementation Details</h2>
<p>RFC 5746 defines two new data structures which are mentioned
here for advanced users:</p>
<ul>
<li>a new pseudo-ciphersuite called the Signaling Cipher Suite
Value (SCSV), "TLS_EMPTY_RENEGOTIATION_INFO_SCSV", and</li>
<li>a new TLS extension called the "Renegotiation Info" (RI).</li>
</ul>
<p>Either of these can be used to signal that an implementation is
RFC 5746-compliant and can perform secure renegotiations. Please
see the <a href=
"http://www.ietf.org/mail-archive/web/tls/current/maillist.html">IETF
email discussion</a> from November 2009 to February 2010 for the
relevant technical discussions.</p>
<p>RFC 5746 allows for clients to send either a SCSV or RI in the
first ClientHello. For maximum interoperability, SunJSSE will use
the SCSV by default, as a few TLS and SSL servers do not handle
unknown extensions correctly. The presence of the SCSV in the
enabled Cipher Suites (i.e.
<code>SSLSocket.setEnabledCipherSuites()/SSLEngine.setEnabledCipherSuites()</code>
will determine whether the SCSV is sent in the initial ClientHello,
or if an RI should be sent instead.</p>
<p>SSLv2 does not support SSL/TLS extensions. If the
<code>SSLv2Hello</code> protocol is enabled, SCSV will be sent in
the initial ClientHello.</p>
<a name="descPhase1" id="descPhase1"></a>
<h2>Description of the Phase 1 Fix</h2>
<p>As mentioned above, the Phase 1 Fix was to disable
renegotiations by default until a RFC 5746-compliant fix could be
developed. Renegotiations could be re-enabled by setting the
<code>sun.security.ssl.allowUnsafeRenegotiation</code> system
property. The Phase 2 fix uses the same system property, with the
addition of the
<code>sun.security.ssl.allowUnsafeRenegotiation</code> system
property to require the use of RFC 5746 messages.</p>
<p>All applications should upgrade to the Phase 2 RFC 5746 fix as
soon as possible.</p>
<!-- *********************************************** -->
<a name="PKCS11" id="PKCS11"></a>
<h1>JCE and Hardware Acceleration/Smartcard Support</h1>
<!-- *********************************************** -->
<a name="UseOfJCE" id="UseOfJCE"></a>
<h2>Use of JCE</h2>
<p>The <a href="../crypto/CryptoSpec.html">Java Cryptography
Extension (JCE)</a> is a set of packages that provides a framework
and implementations for encryption, key generation and key
agreement, and Message Authentication Code (MAC) algorithms. Prior
to Java SE 5, the SunJSSE provider could make use of JCE providers
when configured to do so, but it still contained internal
cryptographic code that did not use JCE. In Java SE 6, the SunJSSE
provider uses JCE exclusively for all of its cryptographic
operations and hence, is able to automatically take advantage of
JCE features and enhancements, including JCE's newly added support
for <a href=
"http://www.rsa.com/rsalabs/node.asp?id=2133">PKCS#11</a>. This
allows the SunJSSE provider in Java SE 6 to be able to use hardware
cryptographic accelerators for significant performance improvements
and to use Smartcards as keystores for greater flexibility in key
and trust management.</p>
<h2><a name="HardwareAccelerators" id=
"HardwareAccelerators"></a>Hardware Accelerators</h2>
<p>Use of hardware cryptographic accelerators is automatic if JCE
has been configured to use the Oracle PKCS#11 provider, which in
turn has been configured to use the underlying accelerator
hardware. The provider must be configured before any other JCE/JCA
providers in the provider list. See the <a href=
"../p11guide.html">PKCS#11 Guide</a> for details on how to
configure the Oracle PKCS#11 provider.</p>
<h2><a name="ConfigSmartcard" id="ConfigSmartcard"></a>Configuring
JSSE to use Smartcards as Keystores and Trust Stores</h2>
<p>Support in JCE for PKCS#11 also enables access to Smartcards as
a keystore. See the <a href="#Customization">Customization</a>
section for details on how to configure the type and location of
the keystores to be used by JSSE. To use a Smartcard as a keystore
or trust store, set the <tt>javax.net.ssl.keyStoreType</tt> and
<tt>javax.net.ssl.trustStoreType</tt> system properties,
respectively, to "pkcs11", and set the
<tt>javax.net.ssl.keyStore</tt> and
<tt>javax.net.ssl.trustStore</tt> system properties, respectively,
to <tt>NONE</tt>. To specify the use of a specific provider, use
the <tt>javax.net.ssl.keyStoreProvider</tt> and
<tt>javax.net.ssl.trustStoreProvider</tt> system properties (e.g.,
"SunPKCS11-joe"). By using these properties, you can configure an
application that previously depended on these properties to access
a file-based keystore to use a Smartcard keystore with no changes
to the application.</p>
<p>Some applications request the use of keystores programmatically.
These applications can continue to use the existing APIs to
instantiate a <tt>Keystore</tt> and pass it to its key manager and
trust manager. If the <tt>Keystore</tt> instance refers to a
PKCS#11 keystore backed by a Smartcard, then the JSSE application
will have access to the keys on the Smartcard.</p>
<!-- ********************************** -->
<a name="MultiDynamicKeystores" id="MultiDynamicKeystores"></a>
<h2>Multiple and Dynamic Keystores</h2>
<p>Smartcards (and other removable tokens) have additional
requirements for an <tt>X509KeyManager</tt>. Different Smartcards
may be present in a Smartcard reader during the lifetime of a Java
application and they may protected using different passwords. The
pre-J2SE 5 APIs and the SunX509 key manager do not accommodate these
requirements well. As a result, in Java SE 5, new APIs were
introduced and a new <tt>X509KeyManager</tt> implementation was
added to the SunJSSE provider.</p>
<p>The <a href=
"../../../../api/java/security/KeyStore.Builder.html"><tt>java.security.KeyStore.Builder</tt></a>
class abstracts the construction and initialization of a KeyStore
object. It supports the use of CallbackHandlers for password
prompting and can be subclassed to support additional features as
desired by an application. For example, it is possible to implement
a Builder that allows individual KeyStore entries to be protected
with different passwords. The <a href=
"../../../../api/javax/net/ssl/KeyStoreBuilderParameters.html"><tt>javax.net.ssl.KeyStoreBuilderParameters</tt></a>
class then can be used to initialize a KeyManagerFactory using one
or more of these Builder objects.</p>
<p>A new <tt>X509KeyManager</tt> implementation in the SunJSSE
provider called "NewSunX509" supports these parameters. If multiple
certificates are available, it also makes the effort to pick a
certificate with the appropriate key usage and prefers valid to
expired certificates</p>
<p>Here is an example of how to tell JSSE to use both a PKCS#11
keystore (which might in turn use a Smartcard) and a PKCS#12
file-based keystore.</p>
<pre class="codeblock">
import javax.net.ssl.*;
import java.security.KeyStore.*;
...

// Specify keystore builder parameters for PKCS#11 keystores
Builder scBuilder = Builder.newInstance("PKCS11", null,
    new CallbackHandlerProtection(myGuiCallbackHandler));

// Specify keystore builder parameters for a specific PKCS#12 keystore
Builder fsBuilder = Builder.newInstance("PKCS12", null,
    new File(pkcsFileName), new PasswordProtection(pkcsKsPassword));

// Wrap them as key manager parameters
ManagerFactoryParameters ksParams =
    new KeyStoreBuilderParameters(
        Arrays.asList(new Builder[] { scBuilder, fsBuilder }));

// Create KeyManagerFactory
KeyManagerFactory factory = KeyManagerFactory.getInstance("NewSunX509");

// Pass builder parameters to factory
factory.init(ksParams);

// Use factory
SSLContext ctx = SSLContext.getInstance("TLS");
ctx.init(factory.getKeyManagers(), null, null);
</pre>
<a name="KRB" id="KRB"></a>
<h1>Kerberos Cipher Suites</h1>
In Java SE 6, the SunJSSE provider has support for Kerberos cipher
suites, as described in <a href=
"http://www.ietf.org/rfc/rfc2712.txt">RFC 2712</a>. The following
cipher suites are supported but not enabled by default.
<pre class="codeblock">
TLS_KRB5_WITH_RC4_128_SHA
TLS_KRB5_WITH_RC4_128_MD5
TLS_KRB5_WITH_3DES_EDE_CBC_SHA
TLS_KRB5_WITH_3DES_EDE_CBC_MD5
TLS_KRB5_WITH_DES_CBC_SHA
TLS_KRB5_WITH_DES_CBC_MD5
TLS_KRB5_EXPORT_WITH_RC4_40_SHA
TLS_KRB5_EXPORT_WITH_RC4_40_MD5
TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA
TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5
</pre>
To enable use of these cipher suites, you must do so explicitly.
See <a href=
"../../../../api/javax/net/ssl/SSLEngine.html#setEnabledCipherSuites(java.lang.String%5B%5D)">
<tt>SSLEngine.setEnabledCipherSuites()</tt></a> and <a href=
"../../../../api/javax/net/ssl/SSLSocket.html#setEnabledCipherSuites(java.lang.String%5B%5D)">
<tt>SSLSocket.setEnabledCipherSuites()</tt></a> for more
information. As with all other SSL/TLS cipher suites, if a cipher
suite is not supported by the peer, then it won't be selected
during cipher negotiation. Furthermore, if the application and/or
server cannot acquire the necessary Kerberos credentials, then the
Kerberos cipher suites also will not be selected.
<p>Here is an example of a TLS client that wants to use only the
<tt>TLS_KRB5_WITH_DES_CBC_SHA</tt> cipher suite.</p>
<pre class="codeblock">
// Create socket
SSLSocketFactory sslsf = (SSLSocketFactory) SSLSocketFactory.getDefault();
SSLSocket sslSocket = (SSLSocket) sslsf.createSocket(tlsServer, serverPort);

// Enable only one cipher suite
String enabledSuites[] = { "TLS_KRB5_WITH_DES_CBC_SHA" };
sslSocket.setEnabledCipherSuites(enabledSuites);
</pre>
<a name="KRBRequire" id="KRBRequire"></a>
<h2>Kerberos Requirements</h2>
You must have the Kerberos infrastructure set up in your deployment
environment before you can use the Kerberos cipher suites with
JSSE. In particular, both the TLS client and server must have
accounts set up with the Kerberos Key Distribution Center (KDC). At
runtime, if one or more of the Kerberos cipher suites have been
enabled, the TLS client and server will acquire their Kerberos
credentials associated with their respective account from the KDC.
For example, a TLS server running on the machine
<tt>mach1.imc.org</tt> in the Kerberos realm <tt>IMC.ORG</tt> must
have an account with the name <tt>host/mach1.imc.org@IMC.ORG</tt>
and be configured to use the KDC for <tt>IMC.ORG</tt>. See the
<a href="../jgss/tutorials/KerberosReq.html">Kerberos
Requirements</a> document for information about using Kerberos with
Java SE .
<p>An application can acquire its Kerberos credentials by using the
<a href="../jaas/JAASRefGuide.html">Java Authentication and
Authorization Service (JAAS)</a> and a Kerberos login module. Java
SE Development Kit 6 comes with a <a href=
"../../../../jre/api/security/jaas/spec/com/sun/security/auth/module/Krb5LoginModule.html">
Kerberos login module</a>. You can use the Kerberos cipher suites
with JSSE with, or without JAAS programming, similar to how you can
use the <a href="../jgss/tutorials/index.html">Java Generic
Security Services (Java GSS)</a> with, or without JAAS
programming.</p>
<p>To use it without JAAS programming, you must use the index names
<tt>"com.sun.net.ssl.server"</tt> or <tt>"other"</tt> for the TLS
server JAAS configuration entry and
<tt>"com.sun.net.ssl.client"</tt> or <tt>"other"</tt> for the TLS
client, and set the system property
<tt>javax.security.auth.useSubjectCredsOnly</tt> to false. For
example, a TLS server that is not using JAAS programming might have
the following JAAS configuration file.</p>
<pre class="codeblock">
com.sun.net.ssl.server {
  com.sun.security.auth.module.Krb5LoginModule required
        principal="host/mach1.imc.org@IMC.ORG"
        useKeyTab=true
        keyTab=mach1.keytab
        storeKey=true;
};
</pre>
An example of how to Java GSS and Kerberos without JAAS programming
is described in the <a href=
"../jgss/tutorials/BasicClientServer.html">Java GSS Tutorial</a>.
You can adapt it to use JSSE by replacing Java GSS calls with JSSE
calls.
<p>To use the Kerberos cipher suites with JAAS programming, you can
use any index name because your application is responsible for
creating the JAAS <tt>LoginContext</tt> using the index name, and
then wrapping the JSSE calls inside of a <tt>Subject.doAs()</tt> or
<tt>Subject.doAsPrivileged()</tt> call. An example of how to use
JAAS with Java GSS and Kerberos is described in the <a href=
"../jgss/tutorials/ClientServer.html">Java GSS Tutorial</a>. You
can adapt it to use JSSE by replacing Java GSS calls with JSSE
calls.</p>
<p>If you have trouble using or configuring the JSSE application to
use Kerberos, see the <a href=
"../jgss/tutorials/Troubleshooting.html">Troubleshooting
section</a> of the Java GSS Tutorial.</p>
<a name="KRBPeerID" id="KRBPeerID"></a>
<h2>Peer Identity Information</h2>
To determine the identity of the peer of an SSL connection, use the
<tt>getPeerPrincipal()</tt> method in the following classes:
<tt>javax.net.ssl.SSLSession</tt>,
<tt>javax.net.ssl.HttpsURLConnection</tt>, and
<tt>javax.net.HandshakeCompletedEvent</tt>. Similarly, to get the
identity that was sent to the peer (to identify the local entity),
use <tt>getLocalPrincipal()</tt> in these classes. For X509-based
cipher suites, these methods will return an instance of
<tt>javax.security.auth.x500.X500Principal</tt>; for Kerberos
cipher suites, these methods will return an instance of
<tt>javax.security.auth.kerberos.KerberosPrincipal</tt>.
<p>Prior to Java SE 5, JSSE applications used
<tt>getPeerCertificates()</tt> and similar methods in
<tt>javax.net.ssl.SSLSession</tt>,
<tt>javax.net.ssl.HttpsURLConnection</tt>, and
<tt>javax.net.HandshakeCompletedEvent</tt> to obtain information
about the peer. When the peer does not have any certificates,
<tt>SSLPeerUnverifiedException</tt> is thrown. The behavior of
these methods remain unchanged in Java SE 6, which means that if
the connection was secured using a Kerberos cipher suite, these
methods will throw <tt>SSLPeerUnverifiedException</tt>.</p>
<p>If the application needs to determine only the identity of the
peer or identity sent to the peer, it should use the
<tt>getPeerPrincipal()</tt> and <tt>getLocalPrincipal()</tt>
methods, respectively. It should use <tt>getPeerCertificates()</tt>
and <tt>getLocalCertificates()</tt> only if it needs to examine the
contents of those certificates. Furthermore, it must be prepared to
handle the case where an authenticated peer might not have any
certificate.</p>
<a name="KRBSM" id="KRBSM"></a>
<h2>Security Manager</h2>
When the security manager has been enabled, in addition to the
<tt>SocketPermission</tt>s needed to communicate with the peer, a
TLS client application that uses the Kerberos cipher suites also
needs the following permission.
<pre class="codeblock">
javax.security.auth.kerberos.ServicePermission(<em>serverPrincipal</em>, "initiate");
</pre>
where <em>serverPrincipal</em> is the Kerberos principal name of
the TLS server that the TLS client will be communicating with, such
as <tt>host/mach1.imc.org@IMC.ORG</tt>. A TLS server application
needs the following permission.
<pre class="codeblock">
javax.security.auth.kerberos.ServicePermission(<em>serverPrincipal</em>, "accept");
</pre>
where <em>serverPrincipal</em> is the Kerberos principal name of
the TLS server, such as <tt>host/mach1.imc.org@IMC.ORG</tt>. If the
server or client needs to contact the KDC (for example, if its
credentials are not cached locally), it also needs the following
permission.
<pre class="codeblock">
javax.security.auth.kerberos.ServicePermission(<em>tgtPrincipal</em>, "initiate");
</pre>
where <em>tgtPrincipal</em> is principal name of the KDC, such as
<tt>krbtgt/IMC.ORG@IMC.ORG</tt>. <a name="KeystoreFormats" id=
"KeystoreFormats"></a>
<h1>Additional Keystore Formats (PKCS12)</h1>
The <a href="http://www.rsa.com/rsalabs/node.asp?id=2138">PKCS#12
(Personal Information Exchange Syntax Standard)</a> specifies a
portable format for storage and/or transport of a user's private
keys, certificates, miscellaneous secrets, and other items. The
<code>SunJSSE</code> provider supplies a complete implementation of
the PKCS12 <code>java.security.KeyStore</code> format for reading
and write pkcs12 files. This format is also supported by other
toolkits and applications for importing and exporting keys and
certificates, such as Netscape/Mozilla, Microsoft's Internet
Explorer, and OpenSSL. For example, these implementations can
export client certificates and keys into a file using the ".p12"
filename extension.
<p>With the <code>SunJSSE</code> provider, you can access PKCS12
keys through the KeyStore API with a keystore type of "pkcs12" (or
"PKCS12", the name is case-insensitive). In addition, you can list
the installed keys and associated certificates using the
<b>keytool</b> command with the <code>-storetype</code> option set
to <code>pkcs12</code>. (See <a href=
"../../../tools/index.html#security">Security Tools</a> for
information about <b>keytool</b>.)</p>
<a name="Troubleshooting" id="Troubleshooting"></a>
<h1>Troubleshooting</h1>
<a name="InstallProbs" id="InstallProbs"></a>
<h2>Configuration Problems</h2>
<h3>CertificateException: (while handshaking)</h3>
<p><b>Problem</b>: When negotiating an SSL connection, the client
or server throws a CertificateException.</p>
<p><b>Cause 1</b>: This is generally caused by the remote side
sending a certificate that is unknown to the local side.</p>
<p><b>Solution 1</b>: The best way to debug this type of problem is
to turn on debugging (see <a href="#Debug">Debugging Utilities</a>)
and watch as certificates are loaded and when certificates are
received via the network connection. Most likely, the received
certificate is unknown to the trust mechanism because the wrong
trust file was loaded. Refer the following sections for more
information:</p>
<ul>
<li><a href="#ClassRelationship">Relationship Between
Classes</a></li>
<li><a href="#TrustManager"><code>TrustManager</code>
Interface</a></li>
<li><a href="#KeyManager"><code>KeyManager</code>
Interface</a></li>
</ul>
<p><b>Cause 2</b>: The system clock is not set correctly.</p>
<p><b>Solution 2</b>: If the clock is not set correctly, the
perceived time may be outside the validity period on one of the
certificates, and unless the certificate can be replaced with a
valid one from a truststore, the system must assume that the
certificate is invalid, and therefore throw the exception.</p>
<!-- ********** 11.22.05 -->
<h3>java.security.KeyStoreException: TrustedCertEntry not
supported</h3>
<p><b>Problem</b>: Attempt to store trusted certificates in PKCS12
keystore throws <code>java.security.KeyStoreException:
TrustedCertEntry not supported.</code></p>
<p><b>Cause 1</b>: We do not support storing trusted certificates
in pkcs12 keystore. PKCS12 is mainly used to deliver private keys
with the associated cert chains. It does not have any notion of
"trusted" certificates. Note that in terms of interoperability,
other pkcs12 vendors have the same restriction. Browsers such as
Mozilla and Internet Explorer do not accept a pkcs12 file with only
trusted certs.</p>
<p><b>Solution 1</b>: Use JKS (or JCEKS) keystore for storing
trusted certificates.</p>
<!-- ********** end 11.22.05 -->
<h3>Runtime Exception: SSL Service Not Available</h3>
<p><b>Problem</b>: When running a program that uses JSSE, an
exception occurs indicating that an SSL service is not available.
For example, an exception similar to one of the following
occurs:</p>
<pre class="codeblock">
    Exception in thread "main"
        java.net.SocketException: no SSL Server Sockets

    Exception in thread "main":
        SSL implementation not available
</pre>
<p><b>Cause</b>: There was a problem with <code>SSLContext</code>
initialization, for example due to an incorrect password on a
keystore or a corrupted keystore. (Note: A JDK vendor once shipped
a keystore in an unknown format, and that caused this type of
error.)</p>
<p><b>Solution</b>: Check initialization parameters. Ensure any
keystores specified are valid and that the passwords specified are
correct. (One way you can check these things is by trying to use
the <a href="../../../tools/index.html#security">keytool</a> to
examine the keystore(s) and the relevant contents.)</p>
<a name="NoAvailCert" id="NoAvailCert"></a>
<h3>Exception, "No available certificate corresponding to the SSL
cipher suites which are enabled"</h3>
<p><b>Problem</b>: When I try to run a simple SSL Server program,
the following exception is thrown:</p>
<pre class="codeblock">
Exception in thread "main" javax.net.ssl.SSLException:
No available certificate corresponding to the SSL
cipher suites which are enabled...
</pre>
<p><b>Cause</b>: Various cipher suites require certain types of key
material. For example, if an RSA cipher suite is enabled, an RSA
<code>keyEntry</code> must be available in the keystore. If no such
key is available, this cipher suite cannot be used. If there are no
available key entries for all of the cipher suites enabled, this
exception is thrown.</p>
<p><b>Solution</b>: Create key entries for the various cipher suite
types, or use an anonymous suite. (Be aware that anonymous
ciphersuites are inherently dangerous because they are vulnerable
to "man-in-the-middle" attacks, see <a href=
"http://www.ietf.org/rfc/rfc2246.txt?number=2246">RFC 2246</a>.)
Refer to the following sections to learn how to pass the correct
keystore and certificates:</p>
<ul>
<li><a href="#ClassRelationship">Relationship Between
Classes</a></li>
<li><a href="#CustomizingStores">Customizing the Default Key and
Trust Stores, Store Types, and Store Passwords</a></li>
<li><a href="#KeystoreFormats">Additional Keystore Formats</a></li>
</ul>
<h3>Runtime Exception: No Cipher Suites in Common</h3>
<p><b>Problem 1</b>: When handshaking, the client and/or server
throw this exception.</p>
<p><b>Cause 1</b>: Both sides of an SSL connection must agree on a
common ciphersuite. If the intersection of the client's ciphersuite
set with the server's ciphersuite set is empty, then you will see
this exception.</p>
<p><b>Solution 1</b>: Configure the enabled cipher suites to
include common ciphersuites, and be sure to provide an appropriate
<code>keyEntry</code> for asymmetric ciphersuites. (See <a href=
"#NoAvailCert">Exception, "No available certificate..."</a> in this
section.)</p>
<p><b>Problem 2</b>: When using Netscape Navigator or Microsoft
Internet Explorer (IE) to access files on a server that only has
DSA-based certificates, a runtime exception occurs indicating that
there are no cipher suites in common.</p>
<p><b>Cause 2</b>: By default, <code>keyEntries</code> created with
keytool use DSA public keys. If only DSA <code>keyEntries</code>
exist in the keystore, only DSA-based ciphersuites can be used. By
default, Navigator and IE send only RSA-based ciphersuites. Since
the intersection of client and server ciphersuite sets is empty,
this exception is thrown.</p>
<p><b>Solution 2</b>: To interact with Navigator or IE, you should
create certificates that use RSA-based keys. To do this, you need
to specify the <code>-keyalg</code> RSA option when using keytool.
For example:</p>
<pre class="codeblock">
    keytool -genkeypair -alias duke \
        -keystore testkeys -keyalg rsa
</pre>
<h3>Slowness of the First JSSE Access</h3>
<p><b>Problem</b>: JSSE seems to stall on the first access.</p>
<p><b>Cause</b>: JSSE must have a secure source of random numbers.
The initialization takes a while.</p>
<p><b>Solution</b>: Provide an alternate generator of random
numbers, or initialize ahead of time when the overhead won't be
noticed:</p>
<pre class="codeblock">
SecureRandom sr = new SecureRandom();
sr.nextInt();
SSLContext.init(..., ..., sr);
</pre>
The <code>&lt;java-home&gt;/lib/security/java.security</code> file
also provides a way to specify the source of seed data for
SecureRandom: see the file for more information. <a name=
"HttpsURLConnectionEx" id="HttpsURLConnectionEx"></a>
<h3>Code Using <code>HttpsURLConnection</code> Class Throws
<code>ClassCastException</code> in JSSE 1.0.x</h3>
<p><b>Problem</b>: The following code snippet was written using
JSSE 1.0.x's <code>com.sun.net.ssl.HttpsURLConnection</code>.</p>
<pre class="codeblock">
import com.sun.net.ssl.*;
...deleted...
HttpsURLConnection urlc = new URL("https://foo.com/").openConnection();
</pre>
When running under this release, this code returns a
<code>javax.net.ssl.HttpsURLConnection</code> and throws a
<code>ClassCastException</code>.
<p><b>Cause</b>: By default, opening an "https" URL will create a
<code>javax.net.ssl.HttpsURLConnection</code>.</p>
<p><b>Solution</b>: Previous releases of the JDK (now known as the
Java SE 6 SDK) did not ship with an "https" URL implementation. The
JSSE 1.0.x implementation did provide such an "https" URL handler,
and the installation guide described how to set the URL handler
search path to obtain a JSSE 1.0.x
<code>com.sun.net.ssl.HttpsURLConnection</code> implementation.</p>
<p>In this release, there is now an "https" handler in the default
URL handler search path. It returns an instance of
<code>javax.net.ssl.HttpsURLConnection</code>. By prepending the
old JSSE 1.0.x implementation path to the URL search path via the
<code>java.protocol.handler.pkgs</code> variable, you can still
obtain a <code>com.sun.net.ssl.HttpsURLConnection</code>, and the
code will no longer throw cast exceptions.</p>
<pre class="codeblock">
% java -Djava.protocol.handler.pkgs=\
  com.sun.net.ssl.internal.www.protocol YourClass
</pre>
or
<pre class="codeblock">
System.setProperty("java.protocol.handler.pkgs",
                   "com.sun.net.ssl.internal.www.protocol");
</pre>
<h3>Socket Disconnected after Sending <code>ClientHello</code>
Message</h3>
<p><b>Problem</b>: A socket attempts to connect, sends a
<code>ClientHello</code> message, and is immediately
disconnected.</p>
<p><b>Cause</b>: Some SSL/TLS servers will disconnect if a
<code>ClientHello</code> message is received in a format it doesn't
understand or with a protocol version number that it doesn't
support.</p>
<p><b>Solution</b>: Try adjusting the protocols in
<code>SSLSocket.setEnabledProtocols</code>. For example, some older
server implementations speak only SSLv3 and do not understand TLS.
Ideally, these implementations should negotiate to SSLv3, but some
simply hang up. For backwards compatibility, some server
implementations (such as SunJSSE) can send SSLv3/TLS
<code>ClientHello</code>s encapsulated in a SSLv2
<code>ClientHello</code> packet. The SunJSSE provider supports this
feature (see <a href="../SunProviders.html#sslv2helloproto">default
settings for SSLv2Hello</a>). If you wish to use this feature, call
<code>setEnabledProtocols</code> to enable <code>SSLv2Hello</code>,
if necessary.</p>
<h3>SunJSSE can not find a JCA/JCE provider which supports a
required algorithm and causes
<code>NoSuchAlgorithmException</code></h3>
<p><b>Problem</b>: A handshake is attempted, and fails when it can
not find a required algorithm. Examples might include:</p>
<pre class="codeblock">
Exception in thread ...deleted...
     ...deleted...
     Caused by java.security.NoSuchAlgorithmException: Cannot find any
provider supporting RSA/ECB/PKCS1Padding
</pre>
or
<pre class="codeblock">
     Caused by java.security.NoSuchAlgorithmException: Cannot find any
provider supporting AES/CBC/NoPadding
</pre>
<p><b>Cause</b>: SunJSSE uses JCE for all its cryptographic
algorithms. By default, the Oracle JDK will use the Standard
Extension ClassLoader to load the SunJCE provider located in
<tt>&lt;java-home&gt;/lib/ext/sunjce_provider.jar</tt>. If the file
can't be found or loaded, or if the SunJCE provider has been
deregistered from the <code>Provider</code> mechanism and an
alternate implementation from JCE isn't available, this exception
will be seen.</p>
<p><b>Solution</b>: Ensure the SunJCE is available by checking the
file is loadable and that the provider is registered with the
<code>Provider</code> interface. Try to run the following code in
the context of your SSL connection.</p>
<pre class="codeblock">
    import javax.crypto.*;

    System.out.println("=====Where did you get AES=====");
    Cipher c = Cipher.getInstance("AES/CBC/NoPadding");
    System.out.println(c.getProvider());
</pre>


<h3>FailedDownloadException thrown when trying to obtain application resources from web server over SSL</h3>

<p><b>Problem</b>: If you receive a <code>com.sun.deploy.net.FailedDownloadException</code> when trying to obtain application resources from your web server over SSL, and your web server uses the Virtual Host with Server Name Indication (SNI) extension (such as Apache HTTP Server), you may have not configured your web server correctly.</p>

<p><b>Cause</b>: Because Java SE 7 and later supports the SNI extension in the JSSE client, the requested host name of the virtual server is included in the first message sent from the client to the server during the SSL handshake. The server may deny the client's request for a connection if the requested host name (the server name indication) does not match the expected server name, which should be specified in the virtual host's configuration. This triggers an SSL handshake unrecognized name alert, which results in a <code>FailedDownloadException</code> being thrown.</p>

<p><strong>Solution</strong>: To better diagnose the problem, enable tracing through the <a href="../../deployment/deployment-guide/console.html">Java Console</a>. See <a href="../../deployment/deployment-guide/tracing_logging.html">Tracing and Logging</a> for more information. If the cause of the problem is <code>javax.net.ssl.SSLProtocolException: handshake alert: unrecognized_name</code>, it is likely that the virtual host configuration for SNI is incorrect. If you are using Apache HTTP Server, see <a href="https://httpd.apache.org/docs/trunk/vhosts/name-based.html">Name-based Virtual Host Support</a> for information about configuring virtual hosts. In particular, ensure that <code>ServerName</code> directive is configured properly in a <code>&lt;VirtualHost&gt;</code> block.</p> 

<p>For more information, see the following:</p>
<ul>
  <li><a href="https://wiki.apache.org/httpd/NameBasedSSLVHostsWithSNI">SSL with Virtual Hosts Using SNI</a> from <a href="https://wiki.apache.org/httpd/FrontPage">Apache HTTP Server Wiki</a>
  <li><a href="https://httpd.apache.org/docs/trunk/ssl/ssl_faq.html">SSL/TLS Strong Encryption: FAQ</a> from <a href="https://httpd.apache.org/docs/">Apache HTTP Server Documentation</a></li>
  <li><a href="https://www.ietf.org/rfc/rfc3546.txt">RFC 3546, Transport Layer Security (TLS) Extensions</a></li>
  <li><a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7194590">Bug 7194590: SSL handshaking error caused by virtual server misconfiguration</a></li>
</ul>












<a name="Debug" id="Debug"></a>
<h2>Debugging Utilities</h2>
<p>JSSE provides dynamic debug tracing support. This is similar to
the support used for debugging access control failures in the Java
SE 6 platform. The generic Java dynamic debug tracing support is
accessed with the system property <code>java.security.debug</code>,
while the JSSE-specific dynamic debug tracing support is accessed
with the system property <code>javax.net.debug</code>.</p>
<p>Note: The debug utility is not an officially supported feature
of JSSE.</p>
<p>To view the options of the JSSE dynamic debug utility, use the
following command-line option on the <code>java</code> command:</p>
<pre class="codeblock">
    -Djavax.net.debug=help
</pre>
<p>Note: If you specify the value <code>help</code> with either
dynamic debug utility when running a program that does not use any
classes that the utility was designed to debug, you will not get
the debugging options.</p>
<p>Here is a complete example of how to get a list of the debug
options:</p>
<pre class="codeblock">
    java -Djavax.net.debug=help <i>MyApp</i>
</pre>
where <i>MyApp</i> is an application that uses some of the JSSE
classes. <i>MyApp</i> will not run after the debug help information
is printed, as the help code causes the application to exit.
<p>Here are the current options:</p>
<pre class="codeblock">
        all        turn on all debugging
        ssl        turn on ssl debugging

        The following can be used with ssl:
            record          enable per-record tracing
            handshake       print each handshake message
            keygen          print key generation data
            session         print session activity
            defaultctx      print default SSL initialization
            sslctx          print SSLContext tracing
            sessioncache    print session cache tracing
            keymanager      print key manager tracing
            trustmanager    print trust manager tracing

        handshake debugging can be widened with:
            data            hex dump of each handshake message
            verbose         verbose handshake message printing

        record debugging can be widened with:
            plaintext       hex dump of record plaintext
            packet          print raw SSL/TLS packets

</pre>
The <code>javax.net.debug</code> property value must specify either
<code>all</code> or <code>ssl</code>, optionally followed by debug
specifiers. You can use one or more options. You do <i>not</i> have
to have a separator between options, although a separator such as
":" or "," helps readability. It doesn't matter what separators you
use, and the ordering of the option keywords is also not important.
<p>For an introduction on reading this debug information, please
refer to the guide, <a href="ReadDebug.html">Debugging SSL/TLS
Connections</a>.</p>
<h3>Examples</h3>
<ul>
<li>To view all debugging messages:
<pre class="codeblock">
java -Djavax.net.debug=all MyApp
</pre></li>
<li>To view the hexadecimal dumps of each handshake message, you
can type the following, where the colons are optional:
<pre class="codeblock">
java -Djavax.net.debug=ssl:handshake:data MyApp
</pre></li>
<li>To view the hexadecimal dumps of each handshake message, and to
print trust manager tracing, you can type the following, where the
commas are optional:
<pre class="codeblock">
java -Djavax.net.debug=SSL,handshake,data,trustmanager MyApp
</pre></li>
</ul>
<a name="CodeExamples" id="CodeExamples"></a>
<h1>Code Examples</h1>
<p>The sections below describe the following code examples:</p>
<ul>
<li><a href="#UnsecureSecure">Converting an Unsecure Socket to a
Secure Socket</a>
<ul>
<li><a href="#NoSSLSocket">Socket Example <i>Without</i>
SSL</a></li>
<li><a href="#WithSSLSocket">Socket Example <i>With</i>
SSL</a></li>
</ul>
</li>
<li><a href="#SampleCode">Running the JSSE Sample Code</a>
<ul>
<li><a href="#SecureConnSample">Sample Code Illustrating a Secure
Socket Connection Between a Client and a Server</a>
<ul>
<li><a href="#SampleConfig">Configuration Requirements</a></li>
<li><a href="#SSC">Running <code>SSLSocketClient</code></a></li>
<li><a href="#SSCWT">Running
<code>SSLSocketClientWithTunneling</code></a></li>
<li><a href="#SSCWCA">Running
<code>SSLSocketClientWithClientAuth</code></a></li>
<li><a href="#RunningCFS">Running
<code>ClassFileServer</code></a></li>
<li><a href="#SSCWCAnCFS">Running
<code>SSLSocketClientWithClientAuth</code> With
<code>ClassFileServer</code></a></li>
</ul>
</li>
<li><a href="#HTTPSSample">Sample Code Illustrating HTTPS
Connections</a>
<ul>
<li><a href="#URLReader">Running URLReader</a></li>
<li><a href="#URLReaderWO">Running URLReaderWithOptions</a></li>
</ul>
</li>
<li><a href="#RMISample">Sample Code Illustrating a Secure RMI
Connection</a></li>
<li><a href="#SSLEngineSample">Sample Code Illustrating the Use of
an <code>SSLEngine</code></a>
<ul>
<li><a href="#RunningSSLEngineSimpleDemo">Running
<code>SSLEngineSimpleDemo</code></a></li>
<li><a href="#RunningNioServer">Running the <code>NIO</code>-based
server</a></li>
</ul>
</li>
</ul>
<br /></li>
<li><a href="#CreateKeystore">Creating a Keystore to Use with
JSSE</a>
<ul>
<li><a href="#CreateSimpleKeystore">Creating a Simple Keystore and
Truststore</a></li>
</ul>
</li>
</ul>
<a name="UnsecureSecure" id="UnsecureSecure"></a>
<h2>Converting an Unsecure Socket to a Secure Socket</h2>
<p>This section provides examples of source code that illustrate
how to use JSSE to convert an unsecure socket connection to a
secure socket connection. The code in this section is excerpted
from the book <i>Java SE 6 Network Security</i> by Marco Pistoia,
et. al.</p>
<p>First, "Socket Example Without SSL" shows sample code that can
be used to set up communication between a client and a server using
unsecure sockets. This code is then modified in "Socket Example
With SSL" to use JSSE to set up secure socket communication.</p>
<h3><a name="NoSSLSocket" id="NoSSLSocket"></a>Socket Example
<i>Without</i> SSL</h3>
<h4>Server Code for Unsecure Socket Communications</h4>
<p>When writing a Java program that acts as a server and
communicates with a client using sockets, the socket communication
is set up with code similar to the following:</p>
<pre class="codeblock">
import java.io.*;
import java.net.*;

. . .

int port = availablePortNumber;

ServerSocket s;

try {
    s = new ServerSocket(port);
    Socket c = s.accept();

    OutputStream out = c.getOutputStream();
    InputStream in = c.getInputStream();

    // Send messages to the client through
    // the OutputStream
    // Receive messages from the client
    // through the InputStream
}

catch (IOException e) {
}
</pre>
<h4>Client Code for Unsecure Socket Communications</h4>
<p>The client code to set up communication with a server using
sockets is similar to the following:</p>
<pre class="codeblock">
import java.io.*;
import java.net.*;

. . .

int port = availablePortNumber;
String host = "hostname";

try {
    s = new Socket(host, port);

    OutputStream out = s.getOutputStream();
    InputStream in = s.getInputStream();

    // Send messages to the server through
    // the OutputStream
    // Receive messages from the server
    // through the InputStream
}

catch (IOException e) {
}
</pre>
<a name="WithSSLSocket" id="WithSSLSocket"></a>
<h3>Socket Example <i>With</i> SSL</h3>
<h4>Server Code for Secure Socket Communications</h4>
<p>When writing a Java program that acts as a server and
communicates with a client using secure sockets, the socket
communication is set up with code similar to the following.
Differences between this program and the one for communication
using unsecure sockets are highlighted in bold.</p>
<pre class="codeblock">
import java.io.*;
import <b>javax.net.ssl.*</b>;

. . .

int port = availablePortNumber;

<b>SSLServerSocket</b> s;

try {
    <b>SSLServerSocketFactory sslSrvFact =
        (SSLServerSocketFactory)
        SSLServerSocketFactory.getDefault();
    s =(SSLServerSocket)sslSrvFact.createServerSocket(port);</b>

    <b>SSLSocket</b> c = <b>(SSLSocket)</b>s.accept();

    OutputStream out = c.getOutputStream();
    InputStream in = c.getInputStream();

    // Send messages to the client through
    // the OutputStream
    // Receive messages from the client
    // through the InputStream
}

catch (IOException e) {
}
</pre>
<h4>Client Code for Secure Socket Communications</h4>
<p>The client code to set up communication with a server using
secure sockets is similar to the following, where differences with
the unsecure version are highlighted in bold:</p>
<pre class="codeblock">
import java.io.*;
import <b>javax.net.ssl.*</b>;

. . .

int port = availablePortNumber;
String host = "hostname";

try {
    <b>SSLSocketFactory sslFact =
      (SSLSocketFactory)SSLSocketFactory.getDefault();
    SSLSocket s =
      (SSLSocket)sslFact.createSocket(host, port);</b>

    OutputStream out = s.getOutputStream();
    InputStream in = s.getInputStream();

    // Send messages to the server through
    // the OutputStream
    // Receive messages from the server
    // through the InputStream
}

catch (IOException e) {
}

</pre>
<a name="SampleCode" id="SampleCode"></a>
<h2>Running the JSSE Sample Code</h2>
<p>The JSSE sample programs illustrate how to use JSSE to:</p>
<ul>
<li><a href="#SecureConnSample">Create a secure socket connection
between a client and a server</a></li>
<li><a href="#HTTPSSample">Create a secure connection to an HTTPS
Web site</a></li>
<li><a href="#RMISample">Use secure communications with
RMI</a></li>
<li><a href="#SSLEngineSample">Illustrate SSLEngine usage</a></li>
</ul>
<p>When using the sample code, be aware that the sample programs
are designed to illustrate how to use JSSE. They are not designed
to be robust applications.</p>
<p>Note: Setting up secure communications involves complex
algorithms. The sample programs provide no feedback during the
setup process. When running the programs, be patient: you may not
see any output for a while. If you run the programs with the system
property <code>javax.net.debug</code> set to <code>all</code>, you
will see more feedback. For an introduction on reading this debug
information, refer to the guide, <a href="ReadDebug.html">Debugging
SSL/TLS Connections</a>. <a name="SamplesLoc" id=
"SamplesLoc"></a></p>
<h3>Where to Find the Sample Code</h3>
<p>Most of the sample code is located in the <a href=
"samples/index.html">samples subdirectory</a> of the same directory
as that containing the document you are reading. Follow that link
to see a listing of all the samples files and to link to the text
files. That page also has a zip file you can download to obtain all
the samples files, which is helpful if you are viewing this
documentation from the web.</p>
<p>The sections below describe the samples. See the <a href=
"samples/README.txt">README</a> for further information.</p>
<a name="SecureConnSample" id="SecureConnSample"></a>
<h3>Sample Code Illustrating a Secure Socket Connection Between a
Client and a Server</h3>
<p>The sample programs in the <code>samples/sockets</code>
directory illustrate how to set up a secure socket connection
between a client and a server.</p>
<p>When running the sample client programs, you can communicate
with an existing server, such as a commercial Web server, or you
can communicate with the sample server program,
<code>ClassFileServer</code>. You can run the sample client and the
sample server programs on different machines connected to the same
network, or you can run them both on one machine but from different
terminal windows.</p>
<p>All the sample <code>SSLSocketClient</code>* programs in the
<code>samples/sockets/client</code> directory (and URLReader*
programs described in <a href="#HTTPSSample">Sample Code
Illustrating HTTPS Connections</a>) can be run with the
<code>ClassFileServer</code> sample server program. An example of
how to do this is shown in <a href="#SSCWCAnCFS">Running
<code>SSLSocketClientWithClientAuth</code> with
<code>ClassFileServer</code></a>. You can make similar changes in
order to run <code>URLReader</code>, <code>SSLSocketClient</code>
or <code>SSLSocketClientWithTunneling</code> with
<code>ClassFileServer</code>.</p>
<p>If an authentication error occurs while attempting to send
messages between the client and the server (whether using a web
server or <code>ClassFileServer</code>), it is most likely because
the necessary keys are not in the <a href="#Stores">truststore</a>
(trust key database). For example, the <code>ClassFileServer</code>
uses a keystore called "testkeys" containing the private key for
"localhost" as needed during the SSL handshake. ("testkeys" is
included in the same <code>samples/sockets/server</code> directory
as the <code>ClassFileServer</code> source.) If the client cannot
find a certificate for the corresponding public key of "localhost"
in the truststore it consults, an authentication error will occur.
Be sure to use the <code>samplecacerts</code> truststore (which
contains "localhost"s public key/cert), as described in the next
section. <a name="SampleConfig" id="SampleConfig"></a></p>
<h3>Configuration Requirements</h3>
<p>When running the sample programs that create a secure socket
connection between a client and a server, you will need to make the
appropriate certificates file (truststore) available. For both the
client and the server programs, you should use the certificates
file <code>samplecacerts</code> from the <code>samples</code>
directory. Using this certificates file will allow the client to
authenticate the server. The file contains all the common
Certification Authority certificates shipped with the JDK (in the
<code>cacerts</code> file), plus a certificate for "localhost"
needed by the client to authenticate "localhost" when communicating
with the sample server <code>ClassFileServer</code>.
(<code>ClassFileServer</code> uses a keystore containing the
private key for "localhost" which corresponds to the public key in
<code>samplecacerts</code>. )</p>
<p>To make the <code>samplecacerts</code> file available to both
the client and the server, you can either copy it to the file
<code>&lt;java-home&gt;/lib/security/jssecacerts</code>, rename it
<code>cacerts</code> and use it to replace the
<code>&lt;java-home&gt;/lib/security/cacerts</code> file, or add
the following option to the command line when running the
<code>java</code> command for both the client and the server:</p>
<pre class="codeblock">
-Djavax.net.ssl.trustStore=path_to_samplecacerts_file
</pre>
<p>(See <a href="#javaHome">The Installation Directory
&lt;java-home&gt;</a> for information about what
<code>&lt;java-home&gt;</code> refers to.)</p>
<p>The password for the <code>samplecacerts</code> truststore is
<code>changeit</code>. You can substitute your own certificates in
the samples, using keytool.</p>
<p>If you use a browser, such as Netscape Navigator or Microsoft's
Internet Explorer, to access the sample SSL server provided in the
<code>ClassFileServer</code> example, a dialog box may pop up with
the message that it does not recognize the certificate. This is
normal because the certificate used with the sample programs is
self-signed and is for testing only. You can accept the certificate
for the current session. After testing the SSL server, you should
exit the browser, which deletes the test certificate from the
browser's namespace.</p>
<p>For client authentication, a separate "duke" certificate is
available in the appropriate directories. The public
key/certificate is also stored in the samplecacerts file.</p>

<a name="SSC" id="SSC"></a>
<h3>Running <code>SSLSocketClient</code></h3>
<p>The <a href=
"samples/sockets/client/SSLSocketClient.java">SSLSocketClient.java</a>
program demonstrates how to create a client to use an
<code>SSLSocket</code> to send an HTTP request and to get a
response from an HTTPS server. The output of this program is the
HTML source for
<code>https://www.verisign.com/index.html</code>.</p>
<p>You must not be behind a firewall to run this program as
shipped. If you run it from behind a firewall, you will get an
<code>UnknownHostException</code> because JSSE can't find a path
through your firewall to <code>www.verisign.com</code>. To create
an equivalent client that can run from behind a firewall, set up
proxy tunneling as illustrated in the sample program
<code>SSLSocketClientWithTunneling</code>.</p>
<a name="SSCWT" id="SSCWT"></a>
<h3>Running <code>SSLSocketClientWithTunneling</code></h3>
<p>The <a href=
"samples/sockets/client/SSLSocketClientWithTunneling.java">SSLSocketClientWithTunneling.java</a>
program illustrates how to do proxy tunneling to access a secure
web server from behind a firewall. To run this program, you must
set the following Java system properties to the appropriate
values:</p>
<code>java -Dhttps.proxyHost=webproxy<br />
-Dhttps.proxyPort=ProxyPortNumber<br />
SSLSocketClientWithTunneling</code>
<p>Note: Proxy specifications with the <code>-D</code> options
(shown in blue) are optional. Also, be sure to replace
<code>webproxy</code> with the name of your proxy host and
<code>ProxyPortNumber</code> with the appropriate port number.</p>
<p>The program will return the HTML source file from
<code>https://www.verisign.com/index.html</code>.</p>
<a name="SSCWCA" id="SSCWCA"></a>
<h3>Running <code>SSLSocketClientWithClientAuth</code></h3>
<p>The <a href=
"samples/sockets/client/SSLSocketClientWithClientAuth.java">SSLSocketClientWithClientAuth.java</a>
program shows how to set up a key manager to do client
authentication if required by a server. This program also assumes
that the client is not outside a firewall. You can modify the
program to connect from inside a firewall by following the example
in <code>SSLSocketClientWithTunneling</code>.</p>
<p>To run this program, you must specify three parameters: host,
port, and requested file path. To mirror the previous examples, you
can run this program without client authentication by setting the
host to <code>www.verisign.com</code>, the port to
<code>443</code>, and the requested file path to
<code>https://www.verisign.com/</code>. The output when using these
parameters is the HTML for the Web site
<code>https://www.verisign.com/</code>.</p>
<p>To run <code>SSLSocketClientWithClientAuth</code> to do client
authentication, you must access a server that requests client
authentication. You can use the sample program
<code>ClassFileServer</code> as this server. This is described in
the following sections.</p>
<a name="RunningCFS" id="RunningCFS"></a>
<h3>Running <code>ClassFileServer</code></h3>
<p>The program referred to herein as <code>ClassFileServer</code>
is made up of two files, <a href=
"samples/sockets/server/ClassFileServer.java">ClassFileServer.java</a>
and <a href=
"samples/sockets/server/ClassServer.java">ClassServer.java</a>.</p>
<p>To execute them, run <code>ClassFileServer.class</code>, which
requires the following parameters:</p>
<ul>
<li><code>port</code> - The port parameter can be any available
unused port number, for example, you can use the number 2001.</li>
<li><code>docroot</code> - This parameter indicates the directory
on the server that contains the file you wish to retrieve. For
example, on Solaris, you can use <code>/home/userid/</code> (where
<code>userid</code> refers to your particular user id), while on
Microsoft Windows systems, you can use <code>c:\</code>.</li>
<li><code>TLS</code> - This is an optional parameter. When used, it
indicates that the server is to use SSL or TLS.</li>
<li><code>true</code> - This is an optional parameter. When used,
client authentication is required. This parameter is only consulted
if the TLS parameter is set.</li>
</ul>
<p>Note 1: The <code>TLS</code> and <code>true</code> parameters
are optional. If you leave them off, indicating that just an
ordinary (not TLS) file server should be used, without
authentication, nothing happens. This is because one side (the
client) is trying to negotiate with TLS, while the other (the
server) isn't, so they can't communicate.</p>
<p>Note 2: The server expects GET requests in the form "GET /...",
where "..." is the path to the file.</p>
<a name="SSCWCAnCFS" id="SSCWCAnCFS"></a>
<h3>Running <code>SSLSocketClientWithClientAuth</code> With
<code>ClassFileServer</code></h3>
<p>You can use the sample programs <a href=
"samples/sockets/client/SSLSocketClientWithClientAuth.java">SSLSocketClientWithClientAuth</a>
and <code>ClassFileServer</code> to set up authenticated
communication, where the client and server are authenticated to
each other. You can run both sample programs on different machines
connected to the same network, or you can run them both on one
machine but from different terminal windows or command prompt
windows. To set up both the client and the server, do the
following:</p>
<ol>
<li>Run the program <code>ClassFileServer</code> from one machine
or terminal window, as described in <a href="#RunningCFS">Running
<code>ClassFileServer</code></a>.</li>
<li>Run the program <code>SSLSocketClientWithClientAuth</code> on
another machine or terminal window.
<code>SSLSocketClientWithClientAuth</code> requires the following
parameters:
<ul>
<li><code>host</code> - This is the hostname of the machine you are
using to run <code>ClassFileServer</code>.</li>
<li><code>port</code> - This is the same port you specified for
<code>ClassFileServer</code>.</li>
<li><code>requestedfilepath</code> - This parameter indicates the
path to the file you want to retrieve from the server. You must
give this parameter as <code>/filepath</code>. Forward slashes are
required in the file path because it is used as part of a GET
statement, which requires forward slashes regardless of what type
of operating system you are running. The statement is formed as
<pre class="codeblock">
"GET " + requestedfilepath + " HTTP/1.0"
</pre></li>
</ul>
</li>
</ol>
NOTE: you can modify the other SSLClient* application's "GET"
commands to connect to a local machine running
<code>ClassFileServer</code>. <a name="HTTPSSample" id=
"HTTPSSample"></a>
<h3>Sample Code Illustrating HTTPS Connections</h3>
<p>There are two primary APIs for accessing secure communications
through JSSE. One way is through a socket-level API which can be
used for arbitrary secure communications, as illustrated by the
<code>SSLSocketClient</code>,
<code>SSLSocketClientWithTunneling</code>, and
<code>SSLSocketClientWithClientAuth</code> (with and without
<code>ClassFileServer</code>) sample programs.</p>
<p>A second, and often simpler way, is through the standard Java
URL API. You can communicate securely with an SSL-enabled web
server by using the "https" URL protocol or scheme using the
<code>java.net.URL</code> class.</p>
<p>Support for "https" URL schemes is implemented in many of the
common browsers, which allows access to secured communications
without requiring the socket-level API provided with JSSE.</p>
<p>An example URL might be:</p>
<i>"https://www.verisign.com"</i>
<p>The trust and key management for the "https" URL implementation
is environment-specific. The JSSE implementation provides an
"https" URL implementation. If you want a different https protocol
implementation to be used, you can set the
<code>java.protocol.handler.pkgs</code> <a href=
"#SystemProps">system property</a> to the package name. See the
<code>java.net.URL</code> class documentation for details.</p>
<p>The samples that you can download with JSSE include two sample
programs that illustrate how to create an HTTPS connection. Both of
these sample programs, <a href=
"samples/urls/URLReader.java"><code>URLReader.java</code></a> and
<a href=
"samples/urls/URLReaderWithOptions.java"><code>URLReaderWithOptions.java</code></a>
are in the <code>urls</code> directory. <a name="URLReader" id=
"URLReader"></a></p>
<h3>Running URLReader</h3>
<p>The <a href="samples/urls/URLReader.java">URLReader.java</a>
program illustrates using the URL class to access a secure site.
The output of this program is the HTML source for
<code>https://www.verisign.com/</code>. By default, the HTTPS
protocol implementation included with JSSE will be utilized. If you
want to use a different implementation, you must set the system
property <code>java.protocol.handler.pkgs</code> value to be the
name of the package containing the implementation.</p>
<p>If you are running the sample code behind a firewall, you must
set the system properties <code>https.proxyHost</code> and
<code>https.proxyPort</code>. For example, to use the proxy host
"webproxy" on port 8080, you can use the following options to the
<code>java</code> command:</p>
<pre class="codeblock">
-Dhttps.proxyHost=webproxy
-Dhttps.proxyPort=8080
</pre>
<p>Alternatively, you can set the system properties within the
source code with the <code>java.lang.System</code> method
<code>setProperty</code>. For example, instead of using the command
line options, you can include the following lines in your
program:</p>
<pre class="codeblock">
System.setProperty("java.protocol.handler.pkgs",
    "com.ABC.myhttpsprotocol");

System.setProperty("https.proxyHost",
    "webproxy");

System.setProperty("https.proxyPort",
    "8080");
</pre>
<p>Note: When running on Windows 95 or Windows 98, the maximum
number of characters allowed in an MS-DOS prompt may not be enough
to include all the command-line options. If you encounter this
problem, either create a .bat file with the entire command or add
the system properties to the source code and recompile the source
code.</p>
<a name="URLReaderWO" id="URLReaderWO"></a>
<h3>Running URLReaderWithOptions</h3>
<p>The <a href=
"samples/urls/URLReaderWithOptions.java">URLReaderWithOptions.java</a>
program is essentially the same as URLReader, except that it allows
you to optionally input any or all of the following system
properties as arguments to the program when you run it:</p>
<ul>
<li>java.protocol.handler.pkgs</li>
<li>https.proxyHost</li>
<li>https.proxyPort</li>
<li>https.cipherSuites</li>
</ul>
<p>To run URLReaderWithOptions, type the following command (all on
one line):</p>
<pre class="codeblock">
java URLReaderWithOptions
     [-h proxyhost -p proxyport]
     [-k protocolhandlerpkgs]
     [-c ciphersarray]
     myApp
</pre>
<p>Note: Multiple protocol handlers can be included in the
<code>protocolhandlerpkgs</code> in a list with items separated by
vertical bars. Multiple SSL cipher suite names can be included in
the <code>ciphersarray</code> in a list with items separated by
commas. The possible cipher suite names are the same as those
returned by the call
<code>SSLSocket.getSupportedCipherSuites()</code>. The suite names
are taken from the SSL and TLS protocol specifications.</p>
<p>You only need a <code>protocolhandlerpkgs</code> argument if you
want to use an HTTPS protocol handler implementation other than the
default one provided by Oracle.</p>
<p>If you are running behind a firewall, you must include arguments
for the proxy host and the proxy port. Additionally, you can
include a list of cipher suites to enable.</p>
<p>Here is an example of running URLReaderWithOptions and
specifying the proxy host "webproxy" on port 8080:</p>
<pre class="codeblock">
java URLReaderWithOptions
    -h webproxy -p 8080
</pre>
<a name="RMISample" id="RMISample"></a>
<h3>Sample Code Illustrating a Secure RMI Connection</h3>
<p>The sample code in the <code>samples/rmi</code> directory
illustrates how to create a secure RMI connection. The sample code
is based on an <a href="../../rmi/socketfactory/index.html">RMI
example</a> that is basically a "Hello World" example modified to
install and use a custom RMI socket factory.</p>
<p>For more information about RMI, see the <a href=
"../../rmi/index.html">Java RMI documentation</a>. This Web page
points to RMI tutorials and other information about RMI.</p>
<a name="SSLEngineSample" id="SSLEngineSample"></a>
<h3>Sample Code Illustrating the Use of an
<code>SSLEngine</code></h3>
<code>SSLEngine</code> was introduced in the Java SE 5 release of
the Java 2 Platform to give application developers flexibility when
choosing I/O and compute strategies. Rather than tie the SSL/TLS
implementation to a specific I/O abstraction (such as
single-threaded <code>SSLSockets</code>), <code>SSLEngine</code>
removes the I/O and compute constraints from the SSL/TLS
implementation.
<p>As mentioned earlier, <code>SSLEngine</code> is an advanced API,
and is not appropriate for casual use. Some introductory sample
code is provided here that helps illustrate its use. The first demo
removes most of the I/O and threading issues, and focuses on many
of the SSLEngine methods. The second demo is a more realistic
example showing how <code>SSLEngine</code> might be combined with
Java NIO to create a rudimentary HTTP/HTTPS server. <a name=
"RunningSSLEngineSimpleDemo" id=
"RunningSSLEngineSimpleDemo"></a></p>
<h3>Running <code>SSLEngineSimpleDemo</code></h3>
The <a href=
"samples/sslengine/SSLEngineSimpleDemo.java">SSLEngineSimpleDemo</a>
is a very simple application that focuses on the operation of the
<code>SSLEngine</code> while simplifying the I/O and threading
issues. This application creates two <code>SSLEngine</code>s which
exchange SSL/TLS messages via common <code>ByteBuffer</code>s. A
single loop serially performs all of the engine operations and
demonstrates how a secure connection is established (handshaking),
how application data is transferred, and how the engine is closed.
<p>The <code>SSLEngineResult</code> provides a great deal of
information about the <code>SSLEngine</code>'s current state. This
example doesn't examine all of the states. It simplifies the I/O
and threading issues to the point that this is not a good example
for a production environment; nonetheless, it is useful to
demonstrate the overall function of the <code>SSLEngine</code>.</p>
<a name="RunningNioServer" id="RunningNioServer"></a>
<h3>Running the <code>NIO</code>-based Server</h3>
<hr />
<b>Note:</b> The server example discussed in this section is
included in the Java SE Development Kit 6. You can find the code
bundled in the <code>&lt;jdk-home&gt;/samples/nio/server</code>
directory.
<hr />
To fully exploit the flexibility provided by
<code>SSLEngine</code>, one must first understand complementary
API's such as I/O and threading models.
<p>An I/O model that large-scale application developers find of use
is NIO <code>SocketChannel</code>s. NIO was introduced in part to
solve some of the scaling problem inherent in the java.net.Socket
API. SocketChannels have many different modes of operation
including:</p>
<ul>
<li>blocking</li>
<li>nonblocking</li>
<li>nonblocking with Selectors</li>
</ul>
Sample code for a bare-bones HTTP server is provided that not only
demonstrates many of the new NIO APIs, and also shows how
<code>SSLEngine</code> can be employed to create a secure HTTPS
server. The server is not production quality, but does show many of
these new APIs in action.
<p>Inside the sample directory is a README.txt file which
introduces the server, explains how to build and configure, and
provides a brief overview of the code layout. The files of most
interest for <code>SSLEngine</code> users are
<code>ChannelIO.java</code> and
<code>ChannelIOSecure.java</code>.</p>
<a name="CreateKeystore" id="CreateKeystore"></a>
<h2>Creating a Keystore to Use with JSSE</h2>
<a name="CreateSimpleKeystore" id="CreateSimpleKeystore"></a>
<h3>Creating a Simple Keystore and Truststore</h3>
In this section, we'll use <code>keytool</code> to create a simple
JKS keystore suitable for use with JSSE. We'll make a
<code>keyEntry</code> (with public/private keys) in the keystore,
then make a corresponding <code>trustedCertEntry</code> (public
keys only) in a truststore. (For client authentication, you'll need
to do a similar process for the client's certificates.) Note:
Storing trust anchors in PKCS12 is not supported. Users should use
JKS for storing trust anchors and PKCS12 for private keys.
<b>Note:</b> It is beyond the scope of this example to explain each
step in detail. If you need more information, please see the
keytool documentation for <a href=
"../../../tools/solaris/keytool.html">Solaris</a> or <a href=
"../../../tools/windows/keytool.html">Microsoft Windows</a>. User
input is shown in boldface font.
<ol>
<li>Create a new keystore and self-signed certificate with
corresponding public/private keys.
<pre class="codeblock">
% <b>keytool -genkeypair -alias duke -keyalg RSA \
  -validity 7 -keystore keystore </b>

 Enter keystore password:  <b>password</b>
 What is your first and last name?
 [Unknown]:  <b>Duke</b>
 What is the name of your organizational unit?
 [Unknown]:  <b>Java Software</b>
 What is the name of your organization?
 [Unknown]:  <b>Oracle, Inc.</b>
 What is the name of your City or Locality?
 [Unknown]:  <b>Palo Alto</b>
 What is the name of your State or Province?
 [Unknown]:  <b>CA</b>
 What is the two-letter country code for this unit?
 [Unknown]:  <b>US</b>
 Is CN=Duke, OU=Java Software, O="Oracle, Inc.",
 L=Palo Alto, ST=CA, C=US correct?
 [no]:  <b>yes</b>

 Enter key password for &lt;duke&gt;
  (RETURN if same as keystore password):  <b>&lt;CR&gt;</b>

</pre>
This is the keystore that the server will use.</li>
<li>Examine the keystore. Notice the entry type is
<code>keyEntry</code> which means that this entry has a private key
associated with it (shown in red).
<pre class="codeblock">
% <b>keytool -list -v -keystore keystore</b>
Enter keystore password:  <b>password</b>

Keystore type: jks
Keystore provider: SUN

Your keystore contains 1 entry

Alias name: duke
Creation date: Dec 20, 2001
Entry type: keyEntry
Certificate chain length: 1
Certificate[1]:
Owner: CN=Duke, OU=Java Software, O="Oracle, Inc.",
L=Palo Alto, ST=CA, C=US
Issuer: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
Serial number: 3c22adc1
Valid from: Thu Dec 20 19:34:25 PST 2001 until: Thu Dec 27 19:34:25 PST 2001
Certificate fingerprints:
    MD5: F1:5B:9B:A1:F7:16:CF:25:CF:F4:FF:35:3F:4C:9C:F0
    SHA1: B2:00:50:DD:B6:CC:35:66:21:45:0F:96:AA:AF:6A:3D:E4:03:7C:74

</pre></li>
<li>Export and examine the self-signed certificate.
<pre class="codeblock">
% <b>keytool -export -alias duke -keystore keystore -rfc \
  -file duke.cer</b>
Enter keystore password:  <b>password</b>
Certificate stored in file &lt;duke.cer&gt;
% <b>cat duke.cer</b>
-----BEGIN CERTIFICATE-----
MIICXjCCAccCBDwircEwDQYJKoZIhvcNAQEEBQAwdjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNB
MRIwEAYDVQQHEwlQYWxvIEFsdG8xHzAdBgNVBAoTFlN1biBNaWNyb3N5c3RlbXMsIEluYy4xFjAU
BgNVBAsTDUphdmEgU29mdHdhcmUxDTALBgNVBAMTBER1a2UwHhcNMDExMjIxMDMzNDI1WhcNMDEx
MjI4MDMzNDI1WjB2MQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExEjAQBgNVBAcTCVBhbG8gQWx0
bzEfMB0GA1UEChMWU3VuIE1pY3Jvc3lzdGVtcywgSW5jLjEWMBQGA1UECxMNSmF2YSBTb2Z0d2Fy
ZTENMAsGA1UEAxMERHVrZTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1loObJzNXsi5aSr8
N4XzDksD6GjTHFeqG9DUFXKEOQetfYXvA8F9uWtz8WInrqskLTNzwXgmNeWkoM7mrPpK6Rf5M3G1
NXtYzvxyi473Gh1h9k7tjJvqSVKO7E1oFkQYeUPYifxmjbSMVirWZgvo2UmA1c76oNK+NhoHJ4qj
eCUCAwEAATANBgkqhkiG9w0BAQQFAAOBgQCRPoQYw9rWWvfLPQuPXowvFmuebsTc28qI7iFWm6BJ
TT/qdmzti7B5MHOt9BeVEft3mMeBU0CS2guaBjDpGlf+zsK/UUi1w9C4mnwGDZzqY/NKKWtLxabZ
5M+4MAKLZ92ePPKGpobM2CPLfM8ap4IgAzCbBKd8+CMp8yFmifze9Q==
-----END CERTIFICATE-----

</pre>
Alternatively, you could generate Certificate Signing Request (CSR)
with <code>-certreq</code> and send that to a Certificate Authority
(CA) for signing, but again, that's beyond the scope of this
example.</li>
<li>Import the certificate into a new truststore.
<pre class="codeblock">
% <b>keytool -import -alias dukecert -file duke.cer \
  -keystore truststore</b>
Enter keystore password:  <b>trustword</b>
Owner: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
Issuer: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
Serial number: 3c22adc1
Valid from: Thu Dec 20 19:34:25 PST 2001 until: Thu Dec 27 19:34:25 PST 2001
Certificate fingerprints:
    MD5: F1:5B:9B:A1:F7:16:CF:25:CF:F4:FF:35:3F:4C:9C:F0
    SHA1: B2:00:50:DD:B6:CC:35:66:21:45:0F:96:AA:AF:6A:3D:E4:03:7C:74
Trust this certificate? [no]:  <b>yes</b>
Certificate was added to keystore

</pre></li>
<li>Examine the truststore. Note that the entry type is
<code>trustedCertEntry</code>, which means that a private key is
not available for this entry (shown in red). It also means that
this file is not suitable as a <code>KeyManager</code>'s keystore.
<pre class="codeblock">
% <b>keytool -list -v -keystore truststore</b>
Enter keystore password:  <b>trustword</b>

Keystore type: jks
Keystore provider: SUN

Your keystore contains 1 entry

Alias name: dukecert
Creation date: Dec 20, 2001
Entry type: trustedCertEntry

Owner: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
Issuer: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
Serial number: 3c22adc1
Valid from: Thu Dec 20 19:34:25 PST 2001 until: Thu Dec 27 19:34:25 PST 2001
Certificate fingerprints:
    MD5: F1:5B:9B:A1:F7:16:CF:25:CF:F4:FF:35:3F:4C:9C:F0
    SHA1: B2:00:50:DD:B6:CC:35:66:21:45:0F:96:AA:AF:6A:3D:E4:03:7C:74

</pre>
Now run your applications with the appropriate key stores. This
example assumes the default <code>X509KeyManager</code> and
<code>X509TrustManager</code> are used, thus we will select the
keystores using the system properties described in <a href=
"#Customization">Customization</a>.
<pre class="codeblock">
% java -Djavax.net.ssl.keyStore=keystore \
  -Djavax.net.ssl.keyStorePassword=password Server

% java -Djavax.net.ssl.trustStore=truststore \
  -Djavax.net.ssl.trustStorePassword=trustword Client
</pre>
<br /></li>
</ol>
<hr />
<b>Note:</b> In this example, we authenticated the server only. If
client authentication is desired, you will need to provide a
similar keystore for the client's keys, and an appropriate
truststore for the server.
<hr />
<hr />
<h1><a name="AppA" id="AppA">Appendix A: Standard Names</a></h1>
<p>The JDK Security API requires and uses a set of standard names
for algorithms, certificate and keystore types. The specification
names previously found here in Appendix A and in the other security
specifications (JCA/CertPath/etc.) have been combined in the
<a href="../StandardNames.html">Standard Names document</a>.
Specific provider information can be found in the <a href=
"../SunProviders.html">Oracle Provider Documentation</a>.</p>
<h1><a name="PLUG" id="PLUG">Appendix B: Provider
Pluggability</a></h1>
<p>JSSE in Java SE 6 is fully pluggable and does not restrict the
use of third party JSSE providers in any way.</p>

<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2014, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
